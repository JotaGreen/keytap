<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Keytap - Scrolling Staff</title>
    <style>
        /* Basic styling for the page */
        body {
            margin: 0;
            overflow: hidden; /* Prevent scrollbars on the body */
            background-color: #f0f0f0; /* Light grey background */
            font-family: sans-serif; /* Simple sans-serif font */
            display: flex;
            justify-content: center; /* Center container horizontally */
            align-items: center; /* Center container vertically */
            min-height: 100vh; /* Ensure body takes full viewport height */
            flex-direction: column; /* Stack container vertically */
        }
        /* Container for canvas and button */
        #staffContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 90%; /* Control overall width */
            max-width: 1200px; /* Optional max width */
        }
        /* Styling for the canvas element */
        canvas {
            background-color: #ffffff; /* White background for the staff */
            display: block; /* Remove extra space below canvas */
            border: 1px solid #ccc; /* Light grey border */
            width: 100%; /* Canvas takes full width of container */
            /* Height is set precisely by JS via canvas.height and canvas.style.height */
            box-sizing: border-box;
            cursor: grab; /* Indicate draggable when paused */
            touch-action: none; /* Prevent default touch actions like scrolling when dragging */
        }
        canvas.dragging {
             cursor: grabbing; /* Change cursor during drag */
        }
        /* Container for buttons */
        #controls {
            margin-top: 15px;
            display: flex;
            gap: 10px; /* Space between buttons */
        }
        /* Styling for the buttons */
        .control-button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 5px;
            border: 1px solid #888;
            background-color: #e0e0e0;
        }
        .control-button:hover {
            background-color: #d0d0d0;
        }
    </style>
    <script src="//cdn.jsdelivr.net/npm/eruda"></script>
    <script src="https://cdn.jsdelivr.net/gh/JotaGreen/keytap@main/midiColorConverter.js"></script>
</head>
<body>
    <div id="staffContainer">
        <canvas id="staffCanvas"></canvas>
        <div id="controls">
            <button id="playPauseButton" class="control-button">Play</button>
            <button id="colorToggleButton" class="control-button">Use Colors</button>
        </div>
    </div>

    <script>
        console.log("Main Keytap script starting execution.");

        // --- Main Configuration Constants ---
        const SCROLL_SPEED_PIXELS_PER_SECOND = 100;
        const PRE_DELAY_SECONDS = 1.0;
        const STAFF_LINE_COLOR = '#000000';
        const NOTE_COLOR = '#333333'; // Default note color (black notes mode)
        // ACCIDENTAL_COLOR is set dynamically in drawAccidental
        const STAFF_LINE_WIDTH = 1; // Base line width
        const NOTE_CORNER_RADIUS = 3;
        const LINE_SPACING = 12;
        const STAFF_PADDING = LINE_SPACING / 2; // Padding above top note edge and below bottom note edge
        const JUDGMENT_LINE_COLOR = '#FF0000';
        const JUDGMENT_LINE_WIDTH = 2; // Base line width
        const JUDGMENT_LINE_X_PERCENT = 20;
        const MIDI_NOTE_MIN = 36; // C2
        const MIDI_NOTE_MAX = 84; // C6
        const ACCIDENTAL_OFFSET_X =13; // Negative offset for left placement
        const ACCIDENTAL_FONT_SIZE = LINE_SPACING * 1.2;
        const LEDGER_LINE_EXTENSION = 4;
        const LEDGER_LINE_WIDTH = 1; // Base line width
        const MIN_DISPLAY_TIME = 0.0;
        // URL for the test JSON data
        const NOTE_DATA_URL = 'https://raw.githubusercontent.com/JotaGreen/keytap/refs/heads/main/test.json';

        // --- DOM Elements ---
        const container = document.getElementById('staffContainer');
        const canvas = document.getElementById('staffCanvas');
        const playPauseButton = document.getElementById('playPauseButton');
        const colorToggleButton = document.getElementById('colorToggleButton');

        // --- Canvas Setup ---
        if (!canvas || !playPauseButton || !container || !colorToggleButton) { console.error("Fatal Error: Required DOM element not found!"); }
        const ctx = canvas.getContext('2d');
        if (!ctx) { console.error("Fatal Error: Could not get 2D rendering context!"); }
        const devicePixelRatio = window.devicePixelRatio || 1;
        console.log(`Device Pixel Ratio: ${devicePixelRatio}`);

        let canvasWidth = 300; // Logical display width
        let canvasHeight = 150; // Logical display height (will be precisely calculated)
        let judgmentLineX; // Logical X position

        // --- Staff Geometry & Note Position Mapping ---
        console.log("Calculating staff line Y positions and note mappings...");
        const HALF_LINE_SPACING = LINE_SPACING / 2;
        let totalStaffHeight = 150;
        const staffPositions = {}; // Holds absolute Y coords for staff lines/spaces
        let diatonicNoteYPositions = {}; // Holds absolute Y coords for note centers
        const midiToDiatonicDegree = [0, 0, 1, 1, 2, 3, 3, 4, 4, 5, 5, 6];

        /** Calculates staff geometry, note Y positions, and total canvas height */
        function setupStaffAndNotes() {
            let currentY_rel = 0; const staffPositions_rel = {};
            staffPositions_rel.F5 = currentY_rel; staffPositions_rel.E5 = staffPositions_rel.F5 + HALF_LINE_SPACING; staffPositions_rel.D5 = staffPositions_rel.F5 + LINE_SPACING; staffPositions_rel.C5 = staffPositions_rel.D5 + HALF_LINE_SPACING; staffPositions_rel.B4 = staffPositions_rel.D5 + LINE_SPACING; staffPositions_rel.A4 = staffPositions_rel.B4 + HALF_LINE_SPACING; staffPositions_rel.G4 = staffPositions_rel.B4 + LINE_SPACING; staffPositions_rel.F4 = staffPositions_rel.G4 + HALF_LINE_SPACING; staffPositions_rel.E4 = staffPositions_rel.G4 + LINE_SPACING; staffPositions_rel.D4 = staffPositions_rel.E4 + HALF_LINE_SPACING; staffPositions_rel.C4 = staffPositions_rel.E4 + LINE_SPACING; staffPositions_rel.B3 = staffPositions_rel.C4 + HALF_LINE_SPACING; staffPositions_rel.A3 = staffPositions_rel.C4 + LINE_SPACING; staffPositions_rel.G3 = staffPositions_rel.A3 + HALF_LINE_SPACING; staffPositions_rel.F3 = staffPositions_rel.A3 + LINE_SPACING; staffPositions_rel.E3 = staffPositions_rel.F3 + HALF_LINE_SPACING; staffPositions_rel.D3 = staffPositions_rel.F3 + LINE_SPACING; staffPositions_rel.C3 = staffPositions_rel.D3 + HALF_LINE_SPACING; staffPositions_rel.B2 = staffPositions_rel.D3 + LINE_SPACING; staffPositions_rel.A2 = staffPositions_rel.B2 + HALF_LINE_SPACING; staffPositions_rel.G2 = staffPositions_rel.B2 + LINE_SPACING;

            const noteNames = ["C", "D", "E", "F", "G", "A", "B"];
            const midiRef = 60; const yRef_rel = staffPositions_rel.C4;
            diatonicNoteYPositions = {};
            let minY_rel = Infinity, maxY_rel = -Infinity;
            for (let midi = MIDI_NOTE_MIN; midi <= MIDI_NOTE_MAX; midi++) {
                const octave = Math.floor(midi / 12) - 1; const noteIndex = midi % 12;
                const diatonicDegree = midiToDiatonicDegree[noteIndex];
                const referenceOctave = Math.floor(midiRef / 12) - 1; const octaveDifference = octave - referenceOctave;
                const stepsFromRefDegree = diatonicDegree - midiToDiatonicDegree[midiRef % 12];
                const totalDiatonicSteps = octaveDifference * 7 + stepsFromRefDegree;
                const yPos_rel = yRef_rel - (totalDiatonicSteps * HALF_LINE_SPACING);
                const baseNoteLetter = noteNames[diatonicDegree]; const baseNoteName = baseNoteLetter + octave;
                if (!(baseNoteName in diatonicNoteYPositions)) { diatonicNoteYPositions[baseNoteName] = yPos_rel; minY_rel = Math.min(minY_rel, yPos_rel); maxY_rel = Math.max(maxY_rel, yPos_rel); }
            }
            console.log("Relative diatonic note Y positions calculated.");

            const noteHeight = LINE_SPACING;
            const topNoteEdgeY_rel = minY_rel - (noteHeight / 2); const bottomNoteEdgeY_rel = maxY_rel + (noteHeight / 2);
            totalStaffHeight = (bottomNoteEdgeY_rel - topNoteEdgeY_rel) + (STAFF_PADDING * 2);
            totalStaffHeight = Math.max(100, totalStaffHeight);
            const yOffset = STAFF_PADDING - topNoteEdgeY_rel;

            for (const key in staffPositions_rel) { const absKey = key.replace('_rel', ''); staffPositions[absKey] = staffPositions_rel[key] + yOffset; }
            for (const key in diatonicNoteYPositions) { diatonicNoteYPositions[key] += yOffset; }

            console.log(`Precise Total Staff Logical Height Calculated (Padding: ${STAFF_PADDING.toFixed(1)}px): ${totalStaffHeight.toFixed(1)}px`);
        }
        setupStaffAndNotes(); // Calculate staff geometry and total height once

        // --- Note Data Storage ---
        let noteMap = null; let notesToDraw = [];

        // --- State Variables ---
        let isRunning = false; let animationFrameId = null;
        let displayTime = PRE_DELAY_SECONDS; let lastTimestamp = 0;
        let isDragging = false; let dragStartX = 0; let dragStartTime = 0;
        let useColoredNotes = false; // Start with black notes by default

        // --- Note Y Position Lookup Function ---
        /** Gets the Y position for a note based on its base diatonic name */
        function getNoteYPosition(noteName) {
            const baseNameMatch = noteName.match(/([A-G])[#b]?(\d)/);
            if (baseNameMatch) {
                const baseName = baseNameMatch[1] + baseNameMatch[2];
                const yPosition = diatonicNoteYPositions[baseName];
                if (yPosition !== undefined) { return yPosition; }
                else { console.error(`Lookup Failure: Base name "${baseName}" (from "${noteName}") not in map!`); return null; }
            } else { console.warn(`Could not parse base note: ${noteName}`); return null; }
        }

        // --- Drawing Functions ---
        /** Draws a single staff line */
        function drawStaffLine(y) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvasWidth, y);
            ctx.lineWidth = STAFF_LINE_WIDTH;
            ctx.strokeStyle = STAFF_LINE_COLOR;
            ctx.stroke();
        }
        /** Draws the 10 lines of the grand staff */
        function drawGrandStaff() {
            drawStaffLine(staffPositions.E4); drawStaffLine(staffPositions.G4); drawStaffLine(staffPositions.B4); drawStaffLine(staffPositions.D5); drawStaffLine(staffPositions.F5);
            drawStaffLine(staffPositions.G2); drawStaffLine(staffPositions.B2); drawStaffLine(staffPositions.D3); drawStaffLine(staffPositions.F3); drawStaffLine(staffPositions.A3);
        }
        /** Helper to draw rounded rectangles */
        function drawRoundedRect(x, y, width, height, radius) {
            if (width < 2 * radius) radius = width / 2; if (height < 2 * radius) radius = height / 2;
            if (width <= 0 || height <= 0) return;
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.arcTo(x + width, y, x + width, y + height, radius);
            ctx.arcTo(x + width, y + height, x, y + height, radius);
            ctx.arcTo(x, y + height, x, y, radius);
            ctx.arcTo(x, y, x + width, y, radius);
            ctx.closePath();
            ctx.fill();
        }
        /** Draws ledger lines for a note if needed */
        function drawLedgerLines(note, x, noteWidth) {
            const y = note.y; if (y === null) return;
            const checkTolerance = HALF_LINE_SPACING / 2;
            ctx.lineWidth = LEDGER_LINE_WIDTH;
            ctx.strokeStyle = STAFF_LINE_COLOR;
            const ledgerXStart = x - LEDGER_LINE_EXTENSION;
            const ledgerXEnd = x + noteWidth + LEDGER_LINE_EXTENSION;
            // Above treble F5
            if (y < staffPositions.F5 - checkTolerance) { for (let lineY = staffPositions.F5 - LINE_SPACING; lineY >= y - checkTolerance; lineY -= LINE_SPACING) { ctx.beginPath(); ctx.moveTo(ledgerXStart, lineY); ctx.lineTo(ledgerXEnd, lineY); ctx.stroke(); } }
            // Middle C (C4)
            if (Math.abs(y - staffPositions.C4) < checkTolerance) { ctx.beginPath(); ctx.moveTo(ledgerXStart, staffPositions.C4); ctx.lineTo(ledgerXEnd, staffPositions.C4); ctx.stroke(); }
            // Below bass G2
            if (y > staffPositions.G2 + checkTolerance) { for (let lineY = staffPositions.G2 + LINE_SPACING; lineY <= y + checkTolerance; lineY += LINE_SPACING) { ctx.beginPath(); ctx.moveTo(ledgerXStart, lineY); ctx.lineTo(ledgerXEnd, lineY); ctx.stroke(); } }
        }
        /** Draws the accidental symbol (# or b) with dynamic color */
        function drawAccidental(note, x) {
            const accidental = note.name.includes('#') ? '♯' : note.name.includes('b') ? '♭' : null;
            if (accidental) {
                if (note.y === null || note.y === undefined) { return; }
                // Set color based on note color mode
                ctx.fillStyle = useColoredNotes ? '#000000' : '#888888'; // Black if notes colored, Gray if notes black
                ctx.font = `${ACCIDENTAL_FONT_SIZE}px sans-serif`;
                ctx.textAlign = 'right'; // Align right for negative offset
                ctx.textBaseline = 'middle';
                const accidentalX = x + ACCIDENTAL_OFFSET_X; // Use negative offset
                const accidentalY = note.y;
                ctx.fillText(accidental, accidentalX, accidentalY);
            }
        }
        /** Draws a single note rectangle and its accidental */
        function drawNote(note, timeToDisplay) {
            if (note.y === null || note.y === undefined) { return; }
            const noteY = note.y;
            const timeUntilJudgment = note.time - timeToDisplay;
            const noteX = judgmentLineX + (timeUntilJudgment * SCROLL_SPEED_PIXELS_PER_SECOND);
            const noteWidth = note.duration * SCROLL_SPEED_PIXELS_PER_SECOND;
            const noteHeight = LINE_SPACING; // Note height matches line spacing

            // Determine note color
            let currentNoteColor = NOTE_COLOR;
            if (useColoredNotes) {
                if (typeof getMidiNoteColor === 'function') {
                    try {
                        const rgbArray = getMidiNoteColor(note.midi);
                        if (rgbArray && rgbArray.length === 3) {
                            currentNoteColor = `rgb(${rgbArray[0]}, ${rgbArray[1]}, ${rgbArray[2]})`;
                        } else { currentNoteColor = NOTE_COLOR; } // Fallback
                    } catch (e) { console.error(`Error calling getMidiNoteColor:`, e); currentNoteColor = NOTE_COLOR; }
                } else { currentNoteColor = NOTE_COLOR; } // Fallback if function missing
            }

            // Draw only if potentially visible (culling)
            if (noteX < canvasWidth && (noteX + noteWidth) > 0) {
                drawLedgerLines(note, noteX, noteWidth); // Draw ledger lines first (behind)
                ctx.fillStyle = currentNoteColor; // Set the determined color
                drawRoundedRect(noteX, noteY - noteHeight / 2, noteWidth, noteHeight, NOTE_CORNER_RADIUS); // Draw note body
                drawAccidental(note, noteX); // Draw accidental last (on top)
            }
        }
        /** Draws the vertical judgment line */
        function drawJudgmentLine() {
             ctx.beginPath();
             ctx.moveTo(judgmentLineX, 0);
             ctx.lineTo(judgmentLineX, canvasHeight);
             ctx.lineWidth = JUDGMENT_LINE_WIDTH;
             ctx.strokeStyle = JUDGMENT_LINE_COLOR;
             ctx.stroke();
        }
        /** Redraws the entire canvas for the current display time */
        function redrawCanvas(timeToDisplay) {
            ctx.save(); // Save default context state
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear physical pixels
            ctx.scale(devicePixelRatio, devicePixelRatio); // Scale context for drawing

            // Draw static elements
            drawGrandStaff();
            drawJudgmentLine();
            // Draw dynamic elements (notes)
            if (notesToDraw.length > 0) {
                notesToDraw.forEach(note => drawNote(note, timeToDisplay));
            }

            ctx.restore(); // Restore context state
        }

        // --- Animation Loop ---
        /** Handles the animation frame updates */
        function animationLoop(timestamp) {
            if (!isRunning) { animationFrameId = null; return; } // Stop if paused
            const currentTimeSeconds = timestamp / 1000.0;
            // Calculate time elapsed since last frame
            const deltaTime = lastTimestamp > 0 ? currentTimeSeconds - lastTimestamp : 0;
            displayTime += deltaTime; // Advance the display time
            lastTimestamp = currentTimeSeconds; // Store timestamp for next frame
            redrawCanvas(displayTime); // Redraw everything for the new time
            animationFrameId = requestAnimationFrame(animationLoop); // Request next frame
        }

        // --- Control Functions ---
        /** Starts the scrolling animation */
        function playAnimation() {
            if (!isRunning) {
                console.log("Playing animation...");
                isRunning = true;
                playPauseButton.textContent = "Pause";
                canvas.style.cursor = 'default'; // Normal cursor when playing
                lastTimestamp = performance.now() / 1000.0; // Reset timestamp for delta calculation
                if (!animationFrameId) { // Avoid multiple loops
                    animationFrameId = requestAnimationFrame(animationLoop);
                }
            }
        }
        /** Stops the scrolling animation */
        function pauseAnimation() {
            if (isRunning) {
                console.log("Pausing animation...");
                isRunning = false; // Flag checked by animationLoop to stop
                playPauseButton.textContent = "Play";
                canvas.style.cursor = 'grab'; // Grab cursor when paused/draggable
            }
        }
        /** Toggles between play and pause states */
        function togglePlayPause() {
            if (isRunning) { pauseAnimation(); } else { playAnimation(); }
        }
        /** Toggles between black/white and colored notes */
        function toggleNoteColors() {
            useColoredNotes = !useColoredNotes; // Flip the state
            colorToggleButton.textContent = useColoredNotes ? "Use Black" : "Use Colors"; // Update button text
            console.log(`Note colors toggled. Using colored notes: ${useColoredNotes}`);
            redrawCanvas(displayTime); // Redraw immediately with new colors
        }

        // --- Event Handlers ---
        /** Handles window resize events */
        function handleResize() {
            console.log("Handling resize...");
            const displayWidth = container.offsetWidth; // Get current container width
            const displayHeight = totalStaffHeight; // Use the fixed calculated height
            canvasWidth = displayWidth; // Update logical width
            canvasHeight = displayHeight; // Update logical height

            // Set canvas buffer size based on pixel ratio for sharpness
            canvas.width = Math.round(displayWidth * devicePixelRatio);
            canvas.height = Math.round(displayHeight * devicePixelRatio);
            // Set canvas display size using CSS
            canvas.style.width = `${displayWidth}px`;
            canvas.style.height = `${displayHeight}px`;

            // Recalculate judgment line logical X position
            judgmentLineX = canvasWidth * (JUDGMENT_LINE_X_PERCENT / 100);

            console.log(`Canvas resized - Display: ${displayWidth.toFixed(0)}x${displayHeight.toFixed(1)}px, Buffer: ${canvas.width}x${canvas.height}px`);
            redrawCanvas(displayTime); // Redraw immediately
        }
        /** Gets the client X coordinate from mouse or touch events */
        function getEventX(event) { return event.touches ? event.touches[0].clientX : event.clientX; }
        /** Handles drag start (mousedown/touchstart) on the canvas */
        function handleDragStart(event) {
            if (!isRunning) { // Only allow dragging when paused
                isDragging = true;
                // Calculate starting X relative to the canvas element
                dragStartX = getEventX(event) - canvas.getBoundingClientRect().left;
                dragStartTime = displayTime; // Store time at drag start
                canvas.classList.add('dragging'); // Add class for styling
                event.preventDefault(); // Prevent default actions like text selection
            }
        }
        /** Handles drag movement (mousemove/touchmove) */
        function handleDragMove(event) {
            if (isDragging) {
                const currentX = getEventX(event) - canvas.getBoundingClientRect().left;
                const deltaX = currentX - dragStartX; // Pixel difference from start
                // Convert pixel delta to time delta (negative because dragging right moves time backward)
                const deltaTimeOffset = deltaX / SCROLL_SPEED_PIXELS_PER_SECOND;
                // Calculate new display time, clamping at the minimum
                displayTime = Math.max(MIN_DISPLAY_TIME, dragStartTime - deltaTimeOffset);
                redrawCanvas(displayTime); // Redraw canvas at the new time
                event.preventDefault();
            }
        }
        /** Handles drag end (mouseup/touchend/mouseleave/touchcancel) */
        function handleDragEnd(event) {
            if (isDragging) {
                isDragging = false;
                canvas.classList.remove('dragging');
                event.preventDefault();
            }
        }

        // --- Initialization ---
        /** Loads note data from the specified URL */
        async function loadNoteData() {
             console.log(`Loading note data from: ${NOTE_DATA_URL}`);
             try {
                  const response = await fetch(NOTE_DATA_URL);
                  if (!response.ok) {
                      throw new Error(`HTTP error! status: ${response.status}`);
                  }
                  const jsonData = await response.json(); // Parse JSON response

                  noteMap = jsonData; // Assign the fetched data
                  console.log("Note data loaded successfully via fetch.");

                  // Process notes from the first track
                  if (noteMap && noteMap.tracks && noteMap.tracks.length > 0 && noteMap.tracks[0].notes) {
                     notesToDraw = noteMap.tracks[0].notes
                         .map(note => ({ ...note, y: getNoteYPosition(note.name) }))
                         .filter(note => note.y !== null); // Filter out notes where Y lookup failed

                     console.log(`Processed ${noteMap.tracks[0].notes.length} notes, ${notesToDraw.length} remain after filtering.`);
                     notesToDraw.sort((a, b) => a.time - b.time); // Sort by time
                     console.log("Notes sorted by start time.");
                  } else {
                      console.error("Error: Fetched note data is missing tracks or notes, or has an invalid format.");
                      notesToDraw = [];
                  }
             } catch (error) {
                 console.error("Fatal Error loading or processing note data:", error);
                 notesToDraw = []; // Ensure notesToDraw is empty on error
                 // Optionally display an error message to the user on the page
             }
         }

        /** Initializes the application */
        async function initialize() {
            console.log("Initializing Keytap visualization...");
            // Initialize Eruda debugging tool
            try { if (typeof eruda !== 'undefined') { eruda.init(); console.log("Eruda initialized."); } else { console.warn("Eruda not found."); } } catch (e) { console.error("Failed to initialize Eruda:", e); }
            // Verify getMidiNoteColor function exists (defined in external script)
            if (typeof getMidiNoteColor === 'function') {
                console.log("getMidiNoteColor function found.");
            } else {
                console.error("CRITICAL: getMidiNoteColor function NOT FOUND. External script might have failed to load or define it.");
            }

            // Staff geometry calculation is now done globally once
            await loadNoteData(); // Load data from URL
            handleResize(); // Set initial size based on container & calculated height
            displayTime = PRE_DELAY_SECONDS; // Set initial view time
            redrawCanvas(displayTime); // Draw initial frame

            // Add event listeners
            window.addEventListener('resize', handleResize);
            playPauseButton.addEventListener('click', togglePlayPause);
            colorToggleButton.addEventListener('click', toggleNoteColors);
            // Dragging listeners
            canvas.addEventListener('mousedown', handleDragStart); window.addEventListener('mousemove', handleDragMove); window.addEventListener('mouseup', handleDragEnd); canvas.addEventListener('mouseleave', handleDragEnd);
            canvas.addEventListener('touchstart', handleDragStart, { passive: false }); window.addEventListener('touchmove', handleDragMove, { passive: false }); window.addEventListener('touchend', handleDragEnd); window.addEventListener('touchcancel', handleDragEnd);

            console.log("Initialization complete. Ready to play.");
        }

        // --- Entry Point ---
        // *** Use window.onload to ensure external scripts are loaded ***
        window.addEventListener('load', initialize);
        console.log("window.onload event listener added.");

    </script>
</body>
</html>
