<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Keytap - Game</title>
    <script src="//cdn.jsdelivr.net/npm/eruda"></script>
    <script src="https://cdn.jsdelivr.net/gh/JotaGreen/keytap@main/midiColorConverter.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/JotaGreen/keytap@main/style.css">
</head>
<body>

    <div id="loadingScreen">
        <h1 id="loadingTitle">Keytap</h1>
        <div class="fileInputContainer">
            <label for="audioFile">Select Audio File (.mp3):</label>
            <input type="file" id="audioFile" accept=".mp3">
        </div>
        <div class="fileInputContainer">
            <label for="notesFile">Select Notes File (.json):</label>
            <input type="file" id="notesFile" accept=".json">
        </div>
        <div id="loadingStatus">Please select both files.</div>
        <button id="startButton" disabled>Start Game</button>
    </div>

    <div id="gameContainer">
        <div id="infoSection">
            <div id="infoTopRow">
                <div id="controlsContainer">
                     <button id="playPauseButton" class="control-button">Play</button>
                     <button id="settingsButton" class="control-button">Settings</button>
                     <div id="comboDisplay">Combo: <span id="comboCount">0</span></div>
                </div>
            </div>
             <div id="healthBarContainer">
                <div id="healthBar"></div>
            </div>
        </div>

        <div id="staffSection">
            <canvas id="staffCanvas"></canvas>
        </div>

        <div id="bottomPanel">
             <div id="keyboardSection">
                 <div class="piano" id="piano">
                     <div class="key white" data-key="C"></div>
                     <div class="key white" data-key="D"></div>
                     <div class="key white" data-key="E"></div>
                     <div class="key white" data-key="F"></div>
                     <div class="key white" data-key="G"></div>
                     <div class="key white" data-key="A"></div>
                     <div class="key white" data-key="B"></div>
                     <div class="key black" data-key="Db"></div>
                     <div class="key black" data-key="Eb"></div>
                     <div class="key black" data-key="Gb"></div>
                     <div class="key black" data-key="Ab"></div>
                     <div class="key black" data-key="Bb"></div>
                 </div>
             </div>
        </div>
    </div>

    <div id="settingsOverlay" class="overlay">
        <div id="settingsPanel" class="overlay-panel">
            <h2>Settings</h2>
            <div class="setting-item">
                <label for="staffScaleValue">Staff Scale (px/s)</label>
                <div class="setting-control">
                    <button id="staffScaleDown" class="control-button adjust-button">-</button>
                    <span id="staffScaleValue" class="setting-value">120</span>
                    <button id="staffScaleUp" class="control-button adjust-button">+</button>
                </div>
            </div>
             <div class="setting-item">
                <label for="hitWindowValue">Hit Window (ms)</label>
                 <div class="setting-control">
                    <button id="hitWindowDown" class="control-button adjust-button">-</button>
                    <span id="hitWindowValue" class="setting-value">140</span>
                    <button id="hitWindowUp" class="control-button adjust-button">+</button>
                </div>
            </div>
            <div class="setting-item">
                <label for="colorToggleSwitch">Color Notes</label>
                 <div class="setting-control">
                     <label class="toggle-switch">
                         <input type="checkbox" id="colorToggleSwitch">
                         <span class="slider"></span>
                     </label>
                 </div>
            </div>
             <div class="setting-item">
                <label for="noDeathToggleSwitch">No Death Mode</label>
                 <div class="setting-control">
                     <label class="toggle-switch">
                         <input type="checkbox" id="noDeathToggleSwitch">
                         <span class="slider"></span>
                     </label>
                 </div>
            </div>
            <button id="closeSettingsButton" class="control-button">Close</button>
        </div>
    </div>

    <div id="scoreOverlay" class="overlay">
        <div id="scorePanel" class="overlay-panel">
            <h2>Results</h2>
            <dl id="scoreStats">
                <dt>Perfect:</dt> <dd><span id="scorePerfectCount">0</span> (<span id="scorePerfectPercent">0</span>%)</dd>
                <dt>Good:</dt>    <dd><span id="scoreGoodCount">0</span> (<span id="scoreGoodPercent">0</span>%)</dd>
                <dt>Miss:</dt>     <dd><span id="scoreMissCount">0</span> (<span id="scoreMissPercent">0</span>%)</dd>
                <dt>Max Combo:</dt><dd><span id="scoreMaxCombo">0</span></dd>
                <dt>Score:</dt>    <dd><span id="scoreTotalScore">0</span></dd>
            </dl>
            <button id="restartButton" class="control-button">Restart</button>
        </div>
    </div>


    <script>
        console.log("Keytap Game script starting execution.");

        // --- Initialize Eruda ---
        try {
            if (typeof eruda !== 'undefined') {
                eruda.init();
                console.log("Eruda initialized.");
            } else { console.warn("Eruda not found."); }
        } catch (e) { console.error("Failed to initialize Eruda:", e); }

        // --- Global Variables & State ---
        // Game Settings & State
        const INITIAL_HEALTH = 50;
        const MAX_HEALTH = 75;
        const MIN_HEALTH = 0;
        const PRE_DELAY_SECONDS = 1.0; // Delay before audio *starts* after visuals begin scrolling
        // Default values (can be changed in settings)
        // CHANGE: Update default staff scale
        let SCROLL_SPEED_PIXELS_PER_SECOND = 120;
        // CHANGE: Update default hit window
        let HIT_WINDOW_GOOD_MS = 140;
        // Derived timing values (updated when HIT_WINDOW_GOOD_MS changes)
        let HIT_WINDOW_PERFECT_MS = HIT_WINDOW_GOOD_MS / 2;
        let HIT_WINDOW_GOOD_SEC = HIT_WINDOW_GOOD_MS / 1000.0;
        let HIT_WINDOW_PERFECT_SEC = HIT_WINDOW_PERFECT_MS / 1000.0;
        // Other state
        let comboCount = 0;
        let playerHealth = INITIAL_HEALTH;
        let totalScore = 0; // Track cumulative score
        let perfectCount = 0;
        let goodCount = 0;
        let missCount = 0;
        let maxCombo = 0;
        let totalNotesInSong = 0; // Set when notes are loaded
        let useColoredNotes = false; // Initial state for color setting
        let noDeathMode = false; // Initial state for no death mode
        let gameIsRunning = false; // Global flag for overall game state (paused/playing)
        let isGameOver = false; // Flag for game over state
        let gameInitialized = false; // Flag to prevent multiple initializations

        // File Loading State
        let audioFileBuffer = null; // Will hold ArrayBuffer of the MP3
        let notesJsonData = null;   // Will hold the parsed JSON object
        let audioFileLoaded = false;
        let notesFileLoaded = false;

        // Audio State (managed by audioModule)
        let audioPauseOffset = 0; // Time offset within the audio buffer where playback was paused

        // --- Global DOM Elements ---
        // Loading Screen
        const loadingScreen = document.getElementById('loadingScreen');
        const audioFileInput = document.getElementById('audioFile');
        const notesFileInput = document.getElementById('notesFile');
        const loadingStatus = document.getElementById('loadingStatus');
        const startButton = document.getElementById('startButton');
        // Game Container
        const gameContainer = document.getElementById('gameContainer');
        const infoSection = document.getElementById('infoSection');
        const staffSection = document.getElementById('staffSection');
        const bottomPanel = document.getElementById('bottomPanel');
        const keyboardSection = document.getElementById('keyboardSection');
        // Info Section Elements
        const playPauseButton = document.getElementById('playPauseButton');
        const settingsButton = document.getElementById('settingsButton');
        const comboCountSpan = document.getElementById('comboCount');
        const healthBarElement = document.getElementById('healthBar');
        // Settings Overlay Elements
        const settingsOverlay = document.getElementById('settingsOverlay');
        const colorToggleSwitch = document.getElementById('colorToggleSwitch');
        const noDeathToggleSwitch = document.getElementById('noDeathToggleSwitch');
        const closeSettingsButton = document.getElementById('closeSettingsButton');
        const staffScaleValueSpan = document.getElementById('staffScaleValue');
        const staffScaleDownButton = document.getElementById('staffScaleDown');
        const staffScaleUpButton = document.getElementById('staffScaleUp');
        const hitWindowValueSpan = document.getElementById('hitWindowValue');
        const hitWindowDownButton = document.getElementById('hitWindowDown');
        const hitWindowUpButton = document.getElementById('hitWindowUp');
        // Score Overlay Elements
        const scoreOverlay = document.getElementById('scoreOverlay');
        const scorePerfectCount = document.getElementById('scorePerfectCount');
        const scorePerfectPercent = document.getElementById('scorePerfectPercent');
        const scoreGoodCount = document.getElementById('scoreGoodCount');
        const scoreGoodPercent = document.getElementById('scoreGoodPercent');
        const scoreMissCount = document.getElementById('scoreMissCount');
        const scoreMissPercent = document.getElementById('scoreMissPercent');
        const scoreMaxCombo = document.getElementById('scoreMaxCombo');
        const scoreTotalScore = document.getElementById('scoreTotalScore');
        const restartButton = document.getElementById('restartButton');


        // --- Scoring Constants ---
        const ENERGY_PERFECT = 2;
        const ENERGY_GOOD = 0; // No base energy for good hits
        // CHANGE: Update miss penalty
        const ENERGY_MISS = -5;

        /**
         * Calculates the combo bonus energy based on the current combo count.
         * @param {number} currentCombo - The current combo count.
         * @returns {number} The additional energy awarded as a combo bonus.
         */
        function calculateComboBonus(currentCombo) {
            if (currentCombo < 10) {
                return 0;
            }
            // Calculate bonus tiers: 10-19 -> +1, 20-29 -> +2, etc.
            const bonus = Math.floor((currentCombo - 1) / 10); // -1 ensures 10-19 is tier 1, 20-29 tier 2 etc.
            return bonus;
        }

        /**
         * Applies scoring changes based on hit type or miss.
         * Updates playerHealth, comboCount, totalScore, maxCombo, and hit counts.
         * @param {'perfect' | 'good' | 'miss'} hitType - The type of hit or miss.
         */
        function applyScore(hitType) {
            if (isGameOver) return; // Don't apply score changes if game is already over

            let baseEnergyChange = 0;
            let comboBroken = false;

            if (hitType === 'perfect') {
                perfectCount++;
                comboCount++;
                baseEnergyChange = ENERGY_PERFECT;
            } else if (hitType === 'good') {
                goodCount++;
                comboCount++;
                baseEnergyChange = ENERGY_GOOD; // Still increments combo
            } else if (hitType === 'miss') {
                missCount++;
                comboBroken = true;
                baseEnergyChange = ENERGY_MISS; // Uses the updated constant
            }

            // Update Max Combo
            if (comboCount > maxCombo) {
                maxCombo = comboCount;
            }

            // Calculate combo bonus only if the combo wasn't broken
            const comboBonus = comboBroken ? 0 : calculateComboBonus(comboCount);
            const totalEnergyChange = baseEnergyChange + comboBonus;

            // Update Player Health (clamped)
            const previousHealth = playerHealth;
            playerHealth = Math.max(MIN_HEALTH, Math.min(MAX_HEALTH, playerHealth + totalEnergyChange));
            const actualHealthChange = playerHealth - previousHealth; // How much health actually changed after clamping

            // Update Total Score (Gain - Loss)
            totalScore += totalEnergyChange; // Add the raw change (can be negative)

            // Reset combo if broken
            if (comboBroken) {
                if (comboCount > 0) { // Only log if combo was actually broken
                     console.log(`Combo Broken! Was: ${comboCount}`);
                     comboCount = 0;
                }
            }

            console.log(`Score Event: ${hitType.toUpperCase()} | Combo: ${comboCount} (Max: ${maxCombo}) | Health Change: ${actualHealthChange} (Raw: ${totalEnergyChange}) | Health: ${playerHealth}/${MAX_HEALTH} | Score: ${totalScore} | P:${perfectCount} G:${goodCount} M:${missCount}`);

            // Update the UI
            updateInfoUI();

            // Check for Game Over AFTER updating UI
            if (playerHealth <= MIN_HEALTH && !isGameOver) {
                 // Check No Death Mode setting
                 if (!noDeathMode) {
                     triggerGameOver(false); // Pass false indicating it wasn't a song finish
                 } else {
                     console.log("Health reached zero, but No Death Mode is active.");
                     // Keep playing, health stays at 0
                 }
            }
        }

        /**
         * Handles the game over state or song completion.
         * @param {boolean} songFinished - True if triggered by song end, false if by death.
         */
        function triggerGameOver(songFinished) {
            if (isGameOver) return; // Prevent multiple triggers

            console.log(songFinished ? "--- SONG FINISHED ---" : "--- GAME OVER ---");
            isGameOver = true;
            gameIsRunning = false; // Ensure game state is set to not running

            // Pause audio and visuals
            if (audioModule) audioModule.pause(); // Use pause to store final offset potentially
            if (staffModule && staffModule.isRunning()) {
                staffModule.pause(); // This should now also handle stopping the animation loop
            }

            // Update button text and disable interactions
            playPauseButton.textContent = songFinished ? "Finished" : "Game Over";
            playPauseButton.disabled = true;
            settingsButton.disabled = true;

            // Show the score screen
            showScoreScreen();
        }

        /** Calculates and displays the final score screen */
        function showScoreScreen() {
            if (!scoreOverlay) return;

            const processedNotes = perfectCount + goodCount + missCount;
            // Use totalNotesInSong if available and greater than 0, otherwise use processedNotes
            const totalNotes = totalNotesInSong > 0 ? totalNotesInSong : processedNotes;

            // Calculate percentages (handle division by zero)
            const perfectPercent = totalNotes > 0 ? ((perfectCount / totalNotes) * 100).toFixed(1) : 0;
            const goodPercent = totalNotes > 0 ? ((goodCount / totalNotes) * 100).toFixed(1) : 0;
            const missPercent = totalNotes > 0 ? ((missCount / totalNotes) * 100).toFixed(1) : 0;

            // Update DOM elements
            scorePerfectCount.textContent = perfectCount;
            scorePerfectPercent.textContent = perfectPercent;
            scoreGoodCount.textContent = goodCount;
            scoreGoodPercent.textContent = goodPercent;
            scoreMissCount.textContent = missCount;
            scoreMissPercent.textContent = missPercent;
            scoreMaxCombo.textContent = maxCombo;
            scoreTotalScore.textContent = totalScore;

            // Make overlay visible
            scoreOverlay.classList.add('visible');
            console.log("Score screen displayed.");
        }

        /** Resets the game state to its initial values for a new game */
        function restartGame() {
            console.log("--- Restarting Game ---");

            // Hide Score Overlay
            if (scoreOverlay) {
                scoreOverlay.classList.remove('visible');
            }

            // Reset Game State Variables
            playerHealth = INITIAL_HEALTH;
            comboCount = 0;
            totalScore = 0;
            perfectCount = 0;
            goodCount = 0;
            missCount = 0;
            maxCombo = 0;
            isGameOver = false;
            gameIsRunning = false; // Start paused
            audioPauseOffset = 0; // Reset pause offset

            // Reset Audio Module State
            if (audioModule) {
                audioModule.stop(); // Ensure any lingering sound stops and resets offset
            }

            // Reset Staff Module State
            if (staffModule) {
                staffModule.resetNotes(); // Reset hit status for all notes
                staffModule.resetTime();  // Reset displayTime to 0
                staffModule.pause();      // Ensure it's paused visually
                staffModule.redraw();     // Redraw initial state
            }

            // Reset UI
            updateInfoUI();
            playPauseButton.textContent = "Play";
            playPauseButton.disabled = false;
            settingsButton.disabled = false;

            console.log("Game state reset.");
        }

        // --- Audio Module (Web Audio API) ---
        const audioModule = (() => {
            // ... (Audio module remains the same as previous version) ...
            console.log("Initializing Audio Module...");
            let audioContext = null;
            let audioBuffer = null; // Decoded audio data
            let sourceNode = null;  // Current audio source playing
            let isAudioReady = false;
            let isAudioPlaying = false; // Flag to track if audio is currently playing or scheduled
            let audioContextStartTime = 0; // Actual context time when playback *actually* began or is scheduled to begin
            let startOffset = 0;    // Offset within the buffer where the latest playback started/resumed

            /** Initialize Audio Context and decode audio data */
            async function init(audioDataArrayBuffer) {
                if (!audioContext) {
                    try {
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        console.log("Audio Context created.");
                    } catch (e) {
                        console.error("Web Audio API is not supported in this browser.", e);
                        alert("Error: Web Audio API is not supported in this browser.");
                        return false;
                    }
                }

                isAudioReady = false;
                audioBuffer = null; // Clear previous buffer
                console.log("Decoding audio data...");
                try {
                    // Ensure context is running before decoding (good practice)
                    await resumeContext();
                    audioBuffer = await audioContext.decodeAudioData(audioDataArrayBuffer);
                    isAudioReady = true;
                    console.log(`Audio data decoded successfully. Duration: ${audioBuffer.duration.toFixed(2)}s`);
                    return true;
                } catch (e) {
                    console.error("Error decoding audio data:", e);
                    alert("Error decoding audio file. Please ensure it's a valid MP3 file.");
                    return false;
                }
            }

            /** Start or resume playback */
            function play(offset = 0) {
                if (!isAudioReady || !audioContext || audioContext.state === 'suspended') {
                    if (audioContext && audioContext.state === 'suspended') {
                        resumeContext().then(() => {
                            console.log("AudioContext resumed during play attempt.");
                            play(offset); // Retry play after resuming
                        }).catch(e => console.error("Failed to resume AudioContext during play:", e));
                    } else {
                        console.warn("Audio not ready or context suspended, cannot play.");
                    }
                    return;
                }
                if (sourceNode) { // Stop previous source if it exists (e.g., rapid pause/play)
                    try { sourceNode.stop(); } catch (e) { /* Ignore error if already stopped */ }
                    sourceNode.disconnect();
                    sourceNode = null; // Ensure clean slate
                }

                sourceNode = audioContext.createBufferSource();
                sourceNode.buffer = audioBuffer;
                sourceNode.connect(audioContext.destination);

                startOffset = offset; // Store the offset where playback should start within the buffer

                // Calculate when the audio should actually start playing in the context timeline
                const delay = (startOffset === 0 && PRE_DELAY_SECONDS > 0) ? PRE_DELAY_SECONDS : 0;
                audioContextStartTime = audioContext.currentTime + delay; // Schedule start time

                console.log(`Audio: Scheduling playback start at context time: ${audioContextStartTime.toFixed(3)}s (Delay: ${delay.toFixed(3)}s) from buffer offset: ${startOffset.toFixed(3)}s`);
                sourceNode.start(audioContextStartTime, startOffset); // Schedule start
                isAudioPlaying = true; // Mark as playing (or scheduled to play)

                sourceNode.onended = () => {
                    const wasPlaying = isAudioPlaying; // Store state before clearing
                    isAudioPlaying = false; // Mark as not playing

                    // Only trigger game over if the audio played fully or near fully
                    // and if the game wasn't already stopped/paused manually
                    const playbackDuration = audioContext.currentTime - audioContextStartTime;
                    const expectedRemainingDuration = audioBuffer.duration - startOffset;

                    if (wasPlaying && !isGameOver && playbackDuration >= 0 && playbackDuration >= expectedRemainingDuration - 0.1) {
                         console.log("Audio source ended naturally (song finished).");
                         if (staffModule && staffModule.isRunning()) {
                              triggerGameOver(true); // Song finished successfully
                         }
                    } else {
                         // console.log("Audio source ended (likely due to stop() or pause).");
                    }
                };
            }

            /** Pause playback */
            function pause() {
                // Use getPlaybackTime to calculate where we are *before* stopping
                const currentOffset = getPlaybackTime();

                if (!sourceNode || !isAudioReady || !audioContext || !isAudioPlaying) {
                    // If not playing, return the last known offset
                    return startOffset;
                }

                console.log(`Audio: Pausing at calculated offset: ${currentOffset.toFixed(3)}s`);

                try {
                    sourceNode.stop(); // Stop playback
                } catch (e) {
                    console.warn("Audio: Error stopping source node (might be already stopped):", e);
                }
                sourceNode.disconnect();
                sourceNode = null;
                isAudioPlaying = false;
                startOffset = currentOffset; // Update startOffset to the paused position

                return startOffset; // Return the offset where it stopped
            }

            /** Stop playback completely */
            function stop() {
                 if (!sourceNode || !isAudioReady || !audioContext) {
                    // If already stopped or not ready, just ensure state is reset
                    isAudioPlaying = false;
                    startOffset = 0;
                    audioContextStartTime = 0;
                    sourceNode = null; // Ensure reference is cleared
                    return;
                 }
                 console.log("Audio: Stopping playback.");
                 try {
                     sourceNode.stop();
                 } catch (e) {
                     console.warn("Audio: Error stopping source node (might be already stopped):", e);
                 }
                 sourceNode.disconnect();
                 sourceNode = null;
                 isAudioPlaying = false;
                 startOffset = 0; // Reset offset
                 audioContextStartTime = 0;
            }


            /** Get the current playback time within the audio buffer */
            function getPlaybackTime() {
                if (!isAudioPlaying || !audioContext || audioContextStartTime === 0) {
                    // If paused, stopped, or not yet started (during initial delay), return the offset
                    return startOffset;
                }
                // Calculate elapsed time since the *scheduled* start time
                const elapsedSinceScheduledStart = audioContext.currentTime - audioContextStartTime;

                // If the current time is before the scheduled start, playback hasn't begun, return the initial offset
                if (elapsedSinceScheduledStart < 0) {
                    return startOffset;
                }

                // Otherwise, return the starting offset plus the time elapsed since the actual start
                return startOffset + elapsedSinceScheduledStart;
            }

            /** Get the AudioContext time */
            function getCurrentContextTime() {
                return audioContext ? audioContext.currentTime : 0;
            }

            /** Resumes the AudioContext if it's suspended */
            function resumeContext() {
                if (audioContext && audioContext.state === 'suspended') {
                    console.log("Audio: Attempting to resume suspended AudioContext...");
                    return audioContext.resume(); // Returns a promise
                }
                return Promise.resolve(); // Return resolved promise if not suspended or not initialized
            }

            return {
                init,
                play,
                pause,
                stop,
                getPlaybackTime,
                getCurrentContextTime,
                isReady: () => isAudioReady,
                resumeContext // Expose resume function
            };
        })();


        // --- Staff Component Logic ---
        const staffModule = (() => {
            // ... (Staff module remains the same as previous version) ...
            console.log("Initializing Staff Module...");

            // --- Configuration Constants ---
            const STAFF_LINE_COLOR = '#000000';
            const NOTE_COLOR = '#333333'; // Default note color (black notes mode)
            const ACCIDENTAL_COLOR_BLACK_NOTES = '#888888'; // Gray for accidentals when notes are black
            const ACCIDENTAL_COLOR_COLOR_NOTES = '#000000'; // Black for accidentals when notes are colored
            const STAFF_LINE_WIDTH = 1;
            const NOTE_CORNER_RADIUS = 3;
            const LINE_SPACING = 12; // Base spacing, affects height
            const STAFF_PADDING = LINE_SPACING / 2;
            const JUDGMENT_LINE_COLOR = '#FF0000';
            const JUDGMENT_LINE_WIDTH = 2;
            const JUDGMENT_LINE_X_PERCENT = 20; // Percentage from left
            const MIDI_NOTE_MIN = 36; // C2
            const MIDI_NOTE_MAX = 84; // C6
            const ACCIDENTAL_PADDING_X = 3; // Padding from note start
            const ACCIDENTAL_FONT_SIZE = LINE_SPACING * 1.2;
            const LEDGER_LINE_EXTENSION = 4;
            const LEDGER_LINE_WIDTH = 1;
            const MIN_DISPLAY_TIME = 0.0; // Visual time should not go below 0
            // Perfect Flash Effect
            const PERFECT_FLASH_COLOR = 'rgba(255, 215, 0, 0.7)'; // Gold, semi-transparent
            const PERFECT_FLASH_DURATION_MS = 150; // How long the flash lasts
            const SONG_END_BUFFER_SEC = 2.0; // How long after the last note ends to *visually* consider song finished (audio handles actual end)

            // --- DOM Elements (Staff Specific) ---
            const canvas = document.getElementById('staffCanvas');

            // --- Canvas Setup ---
            if (!canvas || !staffSection) {
                console.error("Staff Error: Required DOM element (canvas or staffSection) not found!");
                return null; // Stop module initialization
            }
            const ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error("Staff Error: Could not get 2D rendering context!");
                return null;
            }
            const devicePixelRatio = window.devicePixelRatio || 1;

            let canvasWidth = 300; // Logical display width (updated on resize)
            let canvasHeight = 150; // Logical display height (updated on resize)
            let judgmentLineX; // Logical X position (updated on resize)

            // --- Staff Geometry & Note Position Mapping ---
            const HALF_LINE_SPACING = LINE_SPACING / 2;
            let totalStaffLogicalHeight = 150; // Calculated height
            const staffPositions = {}; // Holds absolute Y coords for staff lines/spaces
            let diatonicNoteYPositions = {}; // Holds absolute Y coords for note centers
            const midiToDiatonicDegree = [0, 0, 1, 1, 2, 3, 3, 4, 4, 5, 5, 6]; // C=0, D=1, ..., B=6
            const notePitchClasses = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"]; // For matching key presses

            /** Calculates staff geometry, note Y positions, and total canvas height */
            function setupStaffAndNotes() {
                 // Relative Y positions (Top line F5 is 0)
                let currentY_rel = 0;
                const staffPositions_rel = {};
                staffPositions_rel.F5 = currentY_rel; // Top line treble
                staffPositions_rel.E5 = staffPositions_rel.F5 + HALF_LINE_SPACING;
                staffPositions_rel.D5 = staffPositions_rel.F5 + LINE_SPACING;
                staffPositions_rel.C5 = staffPositions_rel.D5 + HALF_LINE_SPACING;
                staffPositions_rel.B4 = staffPositions_rel.D5 + LINE_SPACING;
                staffPositions_rel.A4 = staffPositions_rel.B4 + HALF_LINE_SPACING;
                staffPositions_rel.G4 = staffPositions_rel.B4 + LINE_SPACING; // Treble G line
                staffPositions_rel.F4 = staffPositions_rel.G4 + HALF_LINE_SPACING;
                staffPositions_rel.E4 = staffPositions_rel.G4 + LINE_SPACING; // Treble E line
                // Space between staves (equivalent to one line space)
                const spaceBetweenStaves = LINE_SPACING;
                staffPositions_rel.D4 = staffPositions_rel.E4 + HALF_LINE_SPACING; // Middle C space (relative)
                staffPositions_rel.C4 = staffPositions_rel.E4 + LINE_SPACING; // Middle C line (relative)
                staffPositions_rel.B3 = staffPositions_rel.C4 + HALF_LINE_SPACING;
                staffPositions_rel.A3 = staffPositions_rel.C4 + LINE_SPACING; // Bass A line
                staffPositions_rel.G3 = staffPositions_rel.A3 + HALF_LINE_SPACING;
                staffPositions_rel.F3 = staffPositions_rel.A3 + LINE_SPACING; // Bass F line
                staffPositions_rel.E3 = staffPositions_rel.F3 + HALF_LINE_SPACING;
                staffPositions_rel.D3 = staffPositions_rel.F3 + LINE_SPACING; // Bass D line
                staffPositions_rel.C3 = staffPositions_rel.D3 + HALF_LINE_SPACING;
                staffPositions_rel.B2 = staffPositions_rel.D3 + LINE_SPACING; // Bass B line
                staffPositions_rel.A2 = staffPositions_rel.B2 + HALF_LINE_SPACING;
                staffPositions_rel.G2 = staffPositions_rel.B2 + LINE_SPACING; // Bottom line bass

                // Map MIDI notes to Y positions
                const noteNames = ["C", "D", "E", "F", "G", "A", "B"];
                const midiRef = 60; // Middle C (C4)
                const yRef_rel = staffPositions_rel.C4; // Y position of Middle C line
                diatonicNoteYPositions = {};
                let minY_rel = Infinity, maxY_rel = -Infinity;

                for (let midi = MIDI_NOTE_MIN; midi <= MIDI_NOTE_MAX; midi++) {
                    const octave = Math.floor(midi / 12) - 1;
                    const noteIndex = midi % 12;
                    const diatonicDegree = midiToDiatonicDegree[noteIndex]; // 0-6

                    const referenceOctave = Math.floor(midiRef / 12) - 1; // Octave of C4 is 4
                    const octaveDifference = octave - referenceOctave; // How many octaves away from C4

                    // Steps relative to C (0) within an octave
                    const stepsFromRefDegree = diatonicDegree - midiToDiatonicDegree[midiRef % 12]; // midiRef%12 is 0 for C

                    // Total diatonic steps away from C4 line (negative is up, positive is down)
                    const totalDiatonicSteps = octaveDifference * 7 + stepsFromRefDegree;

                    // Calculate Y position relative to C4 line
                    const yPos_rel = yRef_rel - (totalDiatonicSteps * HALF_LINE_SPACING);

                    // Store the position using the base note name (e.g., "C4", "G5")
                    const baseNoteLetter = noteNames[diatonicDegree];
                    const baseNoteName = baseNoteLetter + octave;
                    if (!(baseNoteName in diatonicNoteYPositions)) {
                        diatonicNoteYPositions[baseNoteName] = yPos_rel;
                        minY_rel = Math.min(minY_rel, yPos_rel);
                        maxY_rel = Math.max(maxY_rel, yPos_rel);
                    }
                }

                // Calculate total height needed based on highest/lowest note centers + note height + padding
                const noteHeight = LINE_SPACING; // Note height matches line spacing
                const topNoteEdgeY_rel = minY_rel - (noteHeight / 2);
                const bottomNoteEdgeY_rel = maxY_rel + (noteHeight / 2);
                totalStaffLogicalHeight = (bottomNoteEdgeY_rel - topNoteEdgeY_rel) + (STAFF_PADDING * 2);
                totalStaffLogicalHeight = Math.max(100, totalStaffLogicalHeight); // Ensure a minimum height

                // Calculate offset to center the staff vertically within the calculated height
                const yOffset = STAFF_PADDING - topNoteEdgeY_rel;

                // Convert relative Y positions to absolute Y positions within the canvas logical height
                for (const key in staffPositions_rel) {
                    staffPositions[key] = staffPositions_rel[key] + yOffset;
                }
                for (const key in diatonicNoteYPositions) {
                    diatonicNoteYPositions[key] += yOffset;
                }

                console.log(`Staff: Precise Total Staff Logical Height Calculated: ${totalStaffLogicalHeight.toFixed(1)}px`);
            }
            setupStaffAndNotes(); // Calculate staff geometry and total height once

            // --- Note Data Storage ---
            let noteMap = null;
            let notesToDraw = []; // Will contain notes with { ..., y: number, hitStatus: null | 'good' | 'perfect' | 'miss' }
            let songEndTimeVisual = 0; // Time when the last note finishes + buffer (for visual checks)

            // --- State Variables ---
            let isStaffRunning = false; // Internal state for staff animation loop
            let animationFrameId = null;
            let displayTime = 0; // Current visual time, NOW directly reflects audio time
            let isDragging = false;
            let dragStartX = 0;
            let dragStartTime = 0; // Display time at drag start
            let activeFlashes = []; // To store { y: number, endTime: number } for perfect hit flashes

            // --- Note Y Position Lookup Function ---
            function getNoteYPosition(noteName) {
                const baseNameMatch = noteName.match(/([A-G])[#b]?(\d)/);
                if (baseNameMatch) {
                    const baseName = baseNameMatch[1] + baseNameMatch[2];
                    const yPosition = diatonicNoteYPositions[baseName];
                    return (yPosition !== undefined) ? yPosition : null;
                } else {
                    console.warn(`Staff: Could not parse base note name from: "${noteName}"`);
                    return null;
                }
            }

            // --- Helper: Get Pitch Class from Note Name ---
            function getPitchClass(noteName) {
                const match = noteName.match(/([A-G][#b]?)/);
                if (match) {
                    let pc = match[1];
                    // Simple normalization (can be improved with key signature later)
                    if (pc === "C#") pc = "Db";
                    if (pc === "D#") pc = "Eb";
                    if (pc === "F#") pc = "Gb";
                    if (pc === "G#") pc = "Ab";
                    if (pc === "A#") pc = "Bb";
                    return pc;
                }
                return null;
            }


            // --- Drawing Functions ---
            function drawStaffLine(y) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvasWidth, y);
                ctx.lineWidth = STAFF_LINE_WIDTH;
                ctx.strokeStyle = STAFF_LINE_COLOR;
                ctx.stroke();
            }

            function drawGrandStaff() {
                // Treble Staff Lines (E4, G4, B4, D5, F5)
                drawStaffLine(staffPositions.E4); drawStaffLine(staffPositions.G4); drawStaffLine(staffPositions.B4); drawStaffLine(staffPositions.D5); drawStaffLine(staffPositions.F5);
                // Bass Staff Lines (G2, B2, D3, F3, A3)
                drawStaffLine(staffPositions.G2); drawStaffLine(staffPositions.B2); drawStaffLine(staffPositions.D3); drawStaffLine(staffPositions.F3); drawStaffLine(staffPositions.A3);
            }

            function drawRoundedRect(x, y, width, height, radius) {
                 if (width < 2 * radius) radius = width / 2;
                if (height < 2 * radius) radius = height / 2;
                if (width <= 0 || height <= 0) return; // Don't draw zero/negative size rects
                ctx.beginPath();
                ctx.moveTo(x + radius, y);
                ctx.arcTo(x + width, y, x + width, y + height, radius);
                ctx.arcTo(x + width, y + height, x, y + height, radius);
                ctx.arcTo(x, y + height, x, y, radius);
                ctx.arcTo(x, y, x + width, y, radius);
                ctx.closePath();
                ctx.fill();
            }

            function drawLedgerLines(note, x, noteWidth) {
                const y = note.y; if (y === null) return;
                const checkTolerance = HALF_LINE_SPACING / 2; // Tolerance for checking proximity to lines
                ctx.lineWidth = LEDGER_LINE_WIDTH;
                ctx.strokeStyle = STAFF_LINE_COLOR;
                const ledgerXStart = x - LEDGER_LINE_EXTENSION;
                const ledgerXEnd = x + noteWidth + LEDGER_LINE_EXTENSION;

                // Ledger lines ABOVE treble staff (F5 is top line)
                if (y < staffPositions.F5 - checkTolerance) {
                    for (let lineY = staffPositions.F5 - LINE_SPACING; lineY >= y - checkTolerance; lineY -= LINE_SPACING) {
                        ctx.beginPath(); ctx.moveTo(ledgerXStart, lineY); ctx.lineTo(ledgerXEnd, lineY); ctx.stroke();
                    }
                }
                // Ledger line FOR Middle C (C4) - check if note is ON C4 line
                if (Math.abs(y - staffPositions.C4) < checkTolerance) {
                    ctx.beginPath(); ctx.moveTo(ledgerXStart, staffPositions.C4); ctx.lineTo(ledgerXEnd, staffPositions.C4); ctx.stroke();
                }
                 // Ledger lines BELOW bass staff (G2 is bottom line)
                if (y > staffPositions.G2 + checkTolerance) {
                    for (let lineY = staffPositions.G2 + LINE_SPACING; lineY <= y + checkTolerance; lineY += LINE_SPACING) {
                        ctx.beginPath(); ctx.moveTo(ledgerXStart, lineY); ctx.lineTo(ledgerXEnd, lineY); ctx.stroke();
                    }
                }
            }

            function drawAccidental(note, x) {
                 const accidental = note.name.includes('#') ? '♯' : note.name.includes('b') ? '♭' : null;
                if (accidental && note.y !== null) {
                    // Set color based on useColoredNotes global variable
                    ctx.fillStyle = useColoredNotes ? ACCIDENTAL_COLOR_COLOR_NOTES : ACCIDENTAL_COLOR_BLACK_NOTES;
                    ctx.font = `${ACCIDENTAL_FONT_SIZE}px sans-serif`;
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'middle';
                    const accidentalX = x + ACCIDENTAL_PADDING_X;
                    const accidentalY = note.y; // Center vertically on the note's Y
                    ctx.fillText(accidental, accidentalX, accidentalY);
                }
            }

            function drawNote(note, currentDisplayTime) { // Parameter is audio time now
                // Don't draw if already hit successfully
                if (note.hitStatus === 'good' || note.hitStatus === 'perfect') {
                    return;
                }
                // Continue drawing if missed or not yet judged
                if (note.y === null || note.y === undefined) { return; } // Skip notes with invalid Y positions

                const noteY = note.y; // Center Y position
                // Calculate time relative to the *current audio time* (currentDisplayTime)
                const timeUntilJudgment = note.time - currentDisplayTime;
                // Use the global SCROLL_SPEED_PIXELS_PER_SECOND
                const noteX = judgmentLineX + (timeUntilJudgment * SCROLL_SPEED_PIXELS_PER_SECOND);
                const noteWidth = Math.max(1, note.duration * SCROLL_SPEED_PIXELS_PER_SECOND); // Ensure minimum width of 1px
                const noteHeight = LINE_SPACING; // Note height matches line spacing

                // Determine note color (using global useColoredNotes)
                let currentNoteColor = NOTE_COLOR; // Default black/grey
                if (useColoredNotes) { // Check global variable
                    if (typeof getMidiNoteColor === 'function') {
                        try {
                            const rgbArray = getMidiNoteColor(note.midi);
                            if (rgbArray && rgbArray.length === 3) {
                                currentNoteColor = `rgb(${rgbArray[0]}, ${rgbArray[1]}, ${rgbArray[2]})`;
                            } else { currentNoteColor = NOTE_COLOR; } // Fallback
                        } catch (e) { console.error(`Staff: Error calling getMidiNoteColor:`, e); currentNoteColor = NOTE_COLOR; }
                    } else { currentNoteColor = NOTE_COLOR; } // Fallback if function missing
                }

                // Draw only if potentially visible (basic culling)
                // Note: Missed notes will continue to be drawn until they scroll off
                if (noteX < canvasWidth && (noteX + noteWidth) > 0) {
                    drawLedgerLines(note, noteX, noteWidth); // Draw ledger lines first (behind)
                    ctx.fillStyle = currentNoteColor; // Set the determined color
                    drawRoundedRect(noteX, noteY - noteHeight / 2, noteWidth, noteHeight, NOTE_CORNER_RADIUS); // Draw note body
                    // Draw accidental AFTER note body so it's on top
                    drawAccidental(note, noteX);
                }
            }

            function drawJudgmentLine() {
                 ctx.beginPath();
                 ctx.moveTo(judgmentLineX, 0);
                 ctx.lineTo(judgmentLineX, canvasHeight);
                 ctx.lineWidth = JUDGMENT_LINE_WIDTH;
                 ctx.strokeStyle = JUDGMENT_LINE_COLOR;
                 ctx.stroke();
            }

            function drawFlashes(currentDisplayTime) { // Parameter is audio time
                if (activeFlashes.length === 0) return;

                ctx.fillStyle = PERFECT_FLASH_COLOR;
                const flashHeight = LINE_SPACING * 1.5; // Make flash slightly taller than note
                const flashWidth = 10; // Fixed width for the flash effect
                const flashEndTimeContext = audioModule.getCurrentContextTime(); // Use context time for flash expiry

                // Iterate backwards for safe removal
                for (let i = activeFlashes.length - 1; i >= 0; i--) {
                    const flash = activeFlashes[i];
                    // Check against context time when flash should end
                    if (flashEndTimeContext >= flash.endTime) {
                        activeFlashes.splice(i, 1); // Remove expired flash
                    } else {
                        // Draw the flash centered vertically on the note's Y
                        drawRoundedRect(
                            judgmentLineX - flashWidth / 2,
                            flash.y - flashHeight / 2,
                            flashWidth,
                            flashHeight,
                            flashWidth / 2 // Make it oval/circular
                        );
                    }
                }
            }

            /** Main drawing function, called every frame */
            function redrawCanvas() {
                if (!ctx || !audioModule) return; // Don't draw if context or audio module not ready

                // Calculate current display time based DIRECTLY on audio playback time
                displayTime = audioModule.getPlaybackTime();
                // Clamp displayTime to minimum value (e.g., 0)
                displayTime = Math.max(MIN_DISPLAY_TIME, displayTime);

                ctx.save(); // Save default context state
                // Clear the canvas (physical pixels)
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                // Scale the context coordinate system for high-DPI displays
                ctx.scale(devicePixelRatio, devicePixelRatio);

                // --- Drawing ---
                drawGrandStaff();
                drawJudgmentLine();

                // Draw notes based on the calculated displayTime (audio time)
                if (notesToDraw.length > 0) {
                    notesToDraw.forEach(note => drawNote(note, displayTime));
                } else {
                    // Display message if notes haven't loaded yet
                    ctx.fillStyle = '#888';
                    ctx.font = '16px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(noteMap ? 'No notes found in track' : 'Loading notes...', canvasWidth / 2, canvasHeight / 2);
                }

                // Draw perfect hit flashes
                drawFlashes(displayTime);
                // ---------------

                ctx.restore(); // Restore context state
            }

            // --- Animation Loop ---
            function animationLoop() {
                if (!isStaffRunning || isGameOver) { // Stop loop if paused or game over
                     animationFrameId = null;
                     return;
                }

                // --- Check for Missed Notes ---
                // Use the current displayTime (audio time) for checking misses
                const missThresholdTime = displayTime - HIT_WINDOW_GOOD_SEC; // Time when note is too far past judgment line
                notesToDraw.forEach(note => {
                    // Check only notes that haven't been judged yet
                    if (!note.hitStatus && note.time < missThresholdTime) {
                        note.hitStatus = 'miss';
                        applyScore('miss'); // Call the global scoring function
                    }
                });

                // --- Redraw Canvas ---
                // displayTime is calculated inside redrawCanvas based on audio time
                redrawCanvas();

                // --- Request Next Frame ---
                // Continue the loop as long as the staff is running
                animationFrameId = requestAnimationFrame(animationLoop);
            }

            // --- Judgment Logic ---
            /**
             * Judges a key press against notes near the judgment line.
             * @param {string} keyName - The name of the key pressed (e.g., "C", "Db").
             * @returns {string | null} - 'perfect', 'good', or null if no note was hit.
             */
            function judgeKeyPress(keyName) {
                if (!isStaffRunning || isGameOver || !audioModule) return null; // Don't judge if paused, game over, or audio not ready

                // Use the *current audio time* (displayTime) for judgment window calculation
                const currentJudgmentTime = displayTime;
                let hitResult = null; // Track if we hit anything

                // Find the *earliest* unhandled note of the correct pitch class within the "Good" window
                let bestNote = null;
                let minTimeDiff = Infinity;

                for (const note of notesToDraw) {
                    // Skip notes already handled
                    if (note.hitStatus) continue;

                    // Calculate time difference relative to the *current audio time*
                    const timeDiff = note.time - currentJudgmentTime;
                    const absTimeDiff = Math.abs(timeDiff);

                    // Check if within the wider "Good" window (use global variable)
                    if (absTimeDiff <= HIT_WINDOW_GOOD_SEC) {
                        // Check if the pitch class matches
                        const notePitchClass = getPitchClass(note.name);
                        if (notePitchClass === keyName) {
                            // Prioritize notes closer to the judgment line (smaller absTimeDiff)
                            if (absTimeDiff < minTimeDiff) {
                                minTimeDiff = absTimeDiff;
                                bestNote = note;
                            }
                        }
                    }
                }

                // If we found a matching note in the window
                if (bestNote) {
                     // Get context time for flash effect timing
                     const flashEndTimeContext = audioModule.getCurrentContextTime() + PERFECT_FLASH_DURATION_MS / 1000.0;

                    // Determine Perfect or Good based on the absolute time difference (use global variable)
                    if (minTimeDiff <= HIT_WINDOW_PERFECT_SEC) {
                        bestNote.hitStatus = 'perfect';
                        hitResult = 'perfect';
                        // Trigger flash effect - store context time for expiry
                        activeFlashes.push({ y: bestNote.y, endTime: flashEndTimeContext });
                        applyScore('perfect'); // Call the global scoring function
                    } else {
                        bestNote.hitStatus = 'good';
                        hitResult = 'good';
                         applyScore('good'); // Call the global scoring function
                    }
                } else {
                    // No matching note found in the window for this key press
                    // Optionally apply a penalty here
                }

                return hitResult; // Return 'perfect', 'good', or null
            }


            // --- Control Functions (Internal) ---
            function playAnimationInternal(resumeOffset = 0) {
                if (!isStaffRunning && !isGameOver && audioModule && audioModule.isReady()) {
                    console.log(`Staff: Playing animation (Internal), resumeOffset: ${resumeOffset.toFixed(3)}`);
                    isStaffRunning = true;
                    canvas.style.cursor = 'default'; // Normal cursor when playing

                    // Start audio playback from the correct offset (audioModule handles the delay)
                    audioModule.play(resumeOffset);

                    // Start the visual animation loop if not already running
                    if (!animationFrameId) {
                        console.log("Staff: Starting animation frame loop.");
                        animationFrameId = requestAnimationFrame(animationLoop);
                    }
                } else {
                    console.warn("Staff: Cannot play - already running, game over, or audio not ready.");
                }
            }

            function pauseAnimationInternal() {
                if (isStaffRunning) {
                    console.log("Staff: Pausing animation (Internal)...");
                    isStaffRunning = false; // Flag checked by animationLoop to stop
                    canvas.style.cursor = 'grab'; // Grab cursor when paused/draggable

                    // Stop the animation frame loop
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null;
                        console.log("Staff: Stopped animation frame loop.");
                    }

                    // Pause the audio and return the offset
                    return audioModule ? audioModule.pause() : 0;
                }
                return audioModule ? audioModule.getPlaybackTime() : 0; // Return current time if already paused
            }

            /** Resets the hit status of all notes */
            function resetNotesInternal() {
                console.log("Staff: Resetting note hit statuses.");
                notesToDraw.forEach(note => note.hitStatus = null);
                activeFlashes = []; // Clear any active flashes
            }

            /** Resets the display time to the beginning (visual start = audio start = 0) */
            function resetTimeInternal() {
                 console.log("Staff: Resetting display time.");
                 // Reset visual time to 0 (start of audio)
                 displayTime = 0;
                 // Audio offset is reset in global restartGame function via audioModule.stop()
            }

            // --- Event Handlers ---
            function handleResize() {
                const displayWidth = staffSection.offsetWidth;
                const displayHeight = staffSection.offsetHeight;

                if (displayWidth <= 0 || displayHeight <= 0) {
                    console.warn("Staff: Resize called with zero or negative dimensions. Skipping redraw.");
                    return;
                }

                canvasWidth = displayWidth;
                canvasHeight = Math.min(displayHeight, totalStaffLogicalHeight);

                canvas.width = Math.round(canvasWidth * devicePixelRatio);
                canvas.height = Math.round(canvasHeight * devicePixelRatio);

                canvas.style.width = `${canvasWidth}px`;
                canvas.style.height = `${canvasHeight}px`;

                judgmentLineX = canvasWidth * (JUDGMENT_LINE_X_PERCENT / 100);

                redrawCanvas(); // Redraw immediately with new dimensions and current displayTime
            }

            function getEventX(event) { return event.touches ? event.touches[0].clientX : event.clientX; }

            function handleDragStart(event) {
                // Only allow dragging if the game is NOT running and NOT over
                if (!isStaffRunning && !isGameOver) {
                    isDragging = true;
                    dragStartX = getEventX(event) - canvas.getBoundingClientRect().left;
                    // Store the *audio time* (displayTime) at the start of the drag
                    dragStartTime = displayTime;
                    canvas.classList.add('dragging');
                    if (event.target === canvas) {
                         event.preventDefault();
                    }
                }
            }

            function handleDragMove(event) {
                if (isDragging) {
                    const currentX = getEventX(event) - canvas.getBoundingClientRect().left;
                    const deltaX = currentX - dragStartX;
                    const deltaTimeOffset = deltaX / SCROLL_SPEED_PIXELS_PER_SECOND;

                    // Calculate new *audio time* (displayTime) based on drag
                    // Clamp at the minimum allowed time (0)
                    displayTime = Math.max(MIN_DISPLAY_TIME, dragStartTime - deltaTimeOffset);

                    redrawCanvas(); // Redraw canvas at the new audio time
                    if (event.target === canvas) {
                         event.preventDefault();
                    }
                }
            }

            function handleDragEnd(event) {
                if (isDragging) {
                    isDragging = false;
                    canvas.classList.remove('dragging');
                    // Update the global audioPauseOffset based on the final dragged audio time (displayTime)
                    audioPauseOffset = Math.max(0, displayTime); // Ensure non-negative
                    console.log(`Staff: Drag ended. New audio pause offset: ${audioPauseOffset.toFixed(3)}`);
                    if (event.target === canvas) {
                        event.preventDefault();
                    }
                }
            }

            // --- Initialization & Data Loading ---
            /** Loads and processes note data from the provided JSON object */
            function loadNoteData(jsonData) {
                 console.log(`Staff: Processing provided note data...`);
                 try {
                      noteMap = jsonData; // Assign the parsed JSON data

                      // Process notes from the first track ONLY
                      if (noteMap && noteMap.tracks && noteMap.tracks.length > 0 && noteMap.tracks[0].notes) {
                         const rawNotes = noteMap.tracks[0].notes;
                         console.log(`Staff: Found ${rawNotes.length} notes in the first track.`);

                         totalNotesInSong = rawNotes.length; // Store total notes for percentage calculation
                         let lastNoteEndTime = 0;

                         notesToDraw = rawNotes
                             .map(note => {
                                 const yPos = getNoteYPosition(note.name);
                                 const noteEndTime = note.time + note.duration;
                                 if (noteEndTime > lastNoteEndTime) {
                                     lastNoteEndTime = noteEndTime;
                                 }
                                 // Note times remain absolute audio times
                                 return {
                                     ...note,
                                     y: yPos,
                                     hitStatus: null // Initialize hit status
                                 };
                             })
                             .filter(note => note.y !== null); // Filter out notes where Y lookup failed

                         songEndTimeVisual = lastNoteEndTime + SONG_END_BUFFER_SEC; // Visual end time based on audio time
                         console.log(`Staff: Processed ${rawNotes.length} notes, ${notesToDraw.length} remain after Y position lookup. Calculated visual song end time: ${songEndTimeVisual.toFixed(3)}s`);

                         // Sort notes by start time
                         notesToDraw.sort((a, b) => a.time - b.time);

                      } else {
                          console.error("Staff Error: Provided note data is missing tracks[0] or tracks[0].notes, or has an invalid format.");
                          notesToDraw = [];
                          totalNotesInSong = 0;
                          songEndTimeVisual = 0;
                          redrawCanvas(); // Redraw to show potential error message
                          return false; // Indicate failure
                      }
                      return true; // Indicate success
                 } catch (error) {
                     console.error("Staff: Fatal Error processing note data:", error);
                     alert("Error processing notes file. Please ensure it's a valid Keytap JSON file.");
                     notesToDraw = [];
                     totalNotesInSong = 0;
                     songEndTimeVisual = 0;
                     redrawCanvas(); // Redraw to show potential error message
                     return false; // Indicate failure
                 }
             }

            // Public init function for the module
            function init(noteDataJson) { // Accept parsed JSON data
                console.log("Staff Module: Initializing...");
                if (typeof getMidiNoteColor !== 'function') {
                    console.error("Staff CRITICAL: getMidiNoteColor function NOT FOUND.");
                }

                // Load note data immediately
                const notesLoaded = loadNoteData(noteDataJson);
                if (!notesLoaded) {
                    console.error("Staff Module: Failed to load note data during init.");
                    return false; // Initialization fails if notes don't load
                }

                handleResize(); // Set initial size
                // Set initial visual time to 0 (start of audio)
                displayTime = 0;
                redrawCanvas(); // Draw initial frame

                // Add event listeners (Dragging only)
                canvas.addEventListener('mousedown', handleDragStart);
                window.addEventListener('mousemove', handleDragMove);
                window.addEventListener('mouseup', handleDragEnd);
                canvas.addEventListener('touchstart', handleDragStart, { passive: false });
                window.addEventListener('touchmove', handleDragMove, { passive: false });
                window.addEventListener('touchend', handleDragEnd);
                window.addEventListener('touchcancel', handleDragEnd);

                console.log("Staff Module: Initialization complete.");
                return true; // Indicate successful initialization
            }

            // --- Public Interface ---
            return {
                init,
                handleResize,
                play: playAnimationInternal,
                pause: pauseAnimationInternal,
                redraw: redrawCanvas, // Expose redraw for color/settings changes
                isRunning: () => isStaffRunning, // Expose running state
                judgeKeyPress: judgeKeyPress, // Expose judgment function
                resetNotes: resetNotesInternal, // Expose note reset function
                resetTime: resetTimeInternal   // Expose time reset function
            };

        })(); // Immediately invoke the staff module function

        // --- Keyboard Component Logic ---
        const keyboardModule = (() => {
            // ... (Keyboard module remains the same as previous version) ...
            console.log("Initializing Keyboard Module...");

            // --- DOM Elements (Keyboard Specific) ---
            const pianoContainer = document.getElementById('piano');
            if (!pianoContainer) {
                console.error("Keyboard Error: Piano container element not found!");
                return null; // Stop module initialization
            }
            const keys = pianoContainer.querySelectorAll('.key'); // Get all key elements within the piano

            // --- State Variables ---
            let isMouseDown = false; // Track mouse button state specifically for keyboard
            let activeTouches = {}; // Store currently active key per touch identifier: { touchId: keyElement }
            let judgeFunction = null; // To hold the reference to staffModule.judgeKeyPress

            // --- Helper Functions ---
            function pressKey(keyElement) {
                if (isGameOver) return; // Don't allow key presses after game over
                if (keyElement && !keyElement.classList.contains('pressed')) {
                    keyElement.classList.add('pressed');
                    const keyName = keyElement.dataset.key;

                    // Call the judgment function if it exists and game is running
                    if (judgeFunction && gameIsRunning) { // Only judge if game is running visually/audibly
                        // Before judging, ensure AudioContext is running (required for touch interactions)
                        if (audioModule) {
                             audioModule.resumeContext().then(() => {
                                 // Context is running, now judge
                                 judgeFunction(keyName);
                             });
                        } else {
                            console.warn("Keyboard: Audio module not available for context check.");
                            judgeFunction(keyName); // Attempt judgment anyway
                        }
                    } else if (!gameIsRunning) {
                         // Key pressed while paused - potentially provide visual feedback only?
                         // console.log("Keyboard: Key pressed but game is paused.");
                    } else {
                        console.warn("Keyboard: Judge function not available!");
                    }
                }
            }

            function releaseKey(keyElement) {
                if (keyElement && keyElement.classList.contains('pressed')) {
                    keyElement.classList.remove('pressed');
                }
            }

            // --- Event Handlers ---
            // Mouse handlers remain largely the same...
            function handleMouseDown(event) {
                if (event.button !== 0) return;
                const targetKey = event.target.closest('.key');
                if (targetKey && pianoContainer.contains(targetKey)) {
                    isMouseDown = true;
                    pressKey(targetKey);
                    event.preventDefault();
                }
            }
            function handleMouseUp(event) {
                if (event.button !== 0) return;
                if (isMouseDown) {
                    keys.forEach(releaseKey);
                    isMouseDown = false;
                }
            }
            function handleMouseLeave(event) {
                if (isMouseDown && event.target === pianoContainer) {
                    keys.forEach(releaseKey);
                    isMouseDown = false;
                }
            }

            // Touch handlers remain largely the same...
             function handleTouchStart(event) {
                const initialTargetKey = event.target.closest('.key');
                 if (initialTargetKey && pianoContainer.contains(initialTargetKey)) {
                     event.preventDefault();
                 }
                for (let i = 0; i < event.changedTouches.length; i++) {
                    const touch = event.changedTouches[i];
                    const elementUnderTouch = document.elementFromPoint(touch.clientX, touch.clientY);
                    const targetKey = elementUnderTouch ? elementUnderTouch.closest('.key') : null;
                    if (targetKey && pianoContainer.contains(targetKey)) {
                        const touchId = touch.identifier;
                        if (!activeTouches[touchId]) {
                            activeTouches[touchId] = targetKey;
                            pressKey(targetKey); // This now handles the audio context resume check
                        }
                    }
                }
            }
            function handleTouchMove(event) {
                 let shouldPreventDefault = false;
                 for (let i = 0; i < event.changedTouches.length; i++) {
                     const touch = event.changedTouches[i];
                     if (activeTouches[touch.identifier]) {
                         shouldPreventDefault = true;
                         break;
                     }
                 }
                 if (shouldPreventDefault) {
                     event.preventDefault();
                 }
                for (let i = 0; i < event.changedTouches.length; i++) {
                    const touch = event.changedTouches[i];
                    const touchId = touch.identifier;
                    const elementUnderTouch = document.elementFromPoint(touch.clientX, touch.clientY);
                    const currentKey = elementUnderTouch ? elementUnderTouch.closest('.key') : null;
                    const isValidKey = currentKey && pianoContainer.contains(currentKey);
                    const previousKey = activeTouches[touchId];

                    if (previousKey !== undefined) {
                        if (currentKey !== previousKey) {
                            releaseKey(previousKey);
                            if (isValidKey) {
                                activeTouches[touchId] = currentKey;
                                pressKey(currentKey); // Handles audio context check
                            } else {
                                activeTouches[touchId] = null;
                            }
                        }
                    }
                }
            }
            function handleTouchEndOrCancel(event) {
                let shouldPreventDefault = false;
                for (let i = 0; i < event.changedTouches.length; i++) {
                    const touch = event.changedTouches[i];
                    if (activeTouches[touch.identifier]) {
                        shouldPreventDefault = true;
                        break;
                    }
                }
                if (shouldPreventDefault) {
                    event.preventDefault();
                }
                for (let i = 0; i < event.changedTouches.length; i++) {
                    const touch = event.changedTouches[i];
                    const touchId = touch.identifier;
                    const lastKey = activeTouches[touchId];
                    releaseKey(lastKey);
                    delete activeTouches[touchId];
                }
            }

            // Public init function for the module
            function init(judgeKeyPressFunc) { // Accept the judge function as an argument
                console.log("Keyboard Module: Initializing...");
                judgeFunction = judgeKeyPressFunc; // Store the function reference

                // --- Attach Event Listeners ---
                pianoContainer.addEventListener('mousedown', handleMouseDown);
                document.addEventListener('mouseup', handleMouseUp); // Listen on document for mouseup outside piano
                pianoContainer.addEventListener('mouseleave', handleMouseLeave);
                pianoContainer.addEventListener('touchstart', handleTouchStart, { passive: false });
                pianoContainer.addEventListener('touchmove', handleTouchMove, { passive: false });
                pianoContainer.addEventListener('touchend', handleTouchEndOrCancel, { passive: false });
                pianoContainer.addEventListener('touchcancel', handleTouchEndOrCancel, { passive: false });
                pianoContainer.addEventListener('contextmenu', (event) => event.preventDefault());

                console.log("Keyboard Module: Initialization complete.");
            }

            // Expose necessary functions/variables if needed
            return {
                init
            };
        })(); // Immediately invoke the keyboard module function

        // --- Global UI Update Functions ---
        /** Updates the health bar and combo display */
        function updateInfoUI() {
            // ... (remains the same) ...
            if (comboCountSpan) {
                comboCountSpan.textContent = comboCount;
            }
            if (healthBarElement) {
                const healthPercentage = Math.max(0, Math.min(100, (playerHealth / MAX_HEALTH) * 100));
                healthBarElement.style.width = `${healthPercentage}%`;
                if (healthPercentage <= 0) {
                     healthBarElement.style.backgroundColor = '#555555';
                } else if (healthPercentage < 25) {
                    healthBarElement.style.backgroundColor = '#f44336';
                } else if (healthPercentage < 50) {
                    healthBarElement.style.backgroundColor = '#ff9800';
                } else {
                    healthBarElement.style.backgroundColor = '#4CAF50';
                }
            }
        }

        /** Updates the displayed values in the settings panel */
        function updateSettingsUI() {
            // Update derived timing values before updating UI
            updateTimingWindows(); // Ensure perfect window is updated if good window changes

            if (staffScaleValueSpan) {
                staffScaleValueSpan.textContent = SCROLL_SPEED_PIXELS_PER_SECOND;
            }
            if (hitWindowValueSpan) {
                 hitWindowValueSpan.textContent = HIT_WINDOW_GOOD_MS;
            }
             if (colorToggleSwitch) {
                colorToggleSwitch.checked = useColoredNotes;
            }
            if (noDeathToggleSwitch) {
                noDeathToggleSwitch.checked = noDeathMode;
            }
            console.log("Settings UI updated.");
        }

        // --- Global Initialization & Layout Management ---

        /** Handles layout adjustments needed on orientation change or resize */
        function handleLayoutChange() {
            // ... (remains the same) ...
            const orientation = window.matchMedia("(orientation: landscape)").matches ? 'landscape' : 'portrait';
            if (orientation === 'landscape') {
                if (infoSection.parentElement !== bottomPanel) {
                    bottomPanel.insertBefore(infoSection, keyboardSection);
                }
            } else { // Portrait
                if (infoSection.parentElement === bottomPanel) {
                    gameContainer.insertBefore(infoSection, staffSection);
                }
            }
            if (staffModule && typeof staffModule.handleResize === 'function') {
                 setTimeout(staffModule.handleResize, 50);
            } else {
                console.warn("Could not trigger staff resize after layout change.");
            }
        }

        /** Recalculates derived timing variables when HIT_WINDOW_GOOD_MS changes */
        function updateTimingWindows() {
            // Ensure perfect is always half of good
            HIT_WINDOW_PERFECT_MS = Math.floor(HIT_WINDOW_GOOD_MS / 2);
            HIT_WINDOW_GOOD_SEC = HIT_WINDOW_GOOD_MS / 1000.0;
            HIT_WINDOW_PERFECT_SEC = HIT_WINDOW_PERFECT_MS / 1000.0;
            console.log(`Timing windows updated: Good=${HIT_WINDOW_GOOD_MS}ms (${HIT_WINDOW_GOOD_SEC.toFixed(3)}s), Perfect=${HIT_WINDOW_PERFECT_MS}ms (${HIT_WINDOW_PERFECT_SEC.toFixed(3)}s)`);
        }


        /** Initializes all game modules and sets up event listeners AFTER files are loaded */
        async function initializeGame(loadedAudioBuffer, loadedNoteData) {
            if (gameInitialized) {
                console.warn("Game already initialized. Skipping.");
                return;
            }
            console.log("--- Initializing Keytap Game ---");
            loadingStatus.textContent = "Initializing audio...";

            // 1. Initialize Audio Module
            if (!audioModule) {
                 console.error("Audio module failed to load.");
                 loadingStatus.textContent = "Error: Audio module failed.";
                 startButton.disabled = false;
                 return;
            }
            const audioInitialized = await audioModule.init(loadedAudioBuffer);
            if (!audioInitialized) {
                console.error("Audio module initialization failed (decoding error).");
                loadingStatus.textContent = "Error: Failed to decode audio.";
                 startButton.disabled = false;
                 return;
            }
            loadingStatus.textContent = "Initializing visuals...";

            // 2. Initialize Staff Module (pass note data)
            if (!staffModule) {
                 console.error("Staff module failed to load.");
                 loadingStatus.textContent = "Error: Staff module failed.";
                 return;
            }
            const staffInitialized = staffModule.init(loadedNoteData);
             if (!staffInitialized) {
                console.error("Staff module initialization failed (note processing error).");
                loadingStatus.textContent = "Error: Failed to process notes file.";
                 return;
            }

            // 3. Initialize Keyboard Module (pass judge function)
            if (!keyboardModule || typeof staffModule.judgeKeyPress !== 'function') {
                console.error("Keyboard module or staff judge function failed to load/initialize.");
                 loadingStatus.textContent = "Error: Keyboard module failed.";
                return;
            }
            keyboardModule.init(staffModule.judgeKeyPress);


            // 4. Set initial UI states
            updateInfoUI(); // Set initial health bar and combo
            updateSettingsUI(); // Set initial settings display (calls updateTimingWindows)

            // 5. Set initial layout based on current orientation/size
            handleLayoutChange(); // Call this AFTER game container is visible

            // 6. Add Global Event Listeners ---

            // Play/Pause Button
            if (playPauseButton && staffModule && audioModule) {
                playPauseButton.addEventListener('click', () => {
                    if (isGameOver) return; // Don't allow play/pause after game over

                     // Ensure AudioContext is running (user gesture required)
                     audioModule.resumeContext().then(() => {
                         if (gameIsRunning) {
                             // Pause the game
                             audioPauseOffset = staffModule.pause(); // Pause visuals & audio, get offset
                             playPauseButton.textContent = "Play";
                             gameIsRunning = false;
                             console.log(`Game Paused. Audio offset: ${audioPauseOffset.toFixed(3)}`);
                         } else {
                             // Play the game (from the beginning or resume)
                             staffModule.play(audioPauseOffset); // Play visuals & audio from offset
                             playPauseButton.textContent = "Pause";
                             gameIsRunning = true;
                             console.log(`Game Playing. Resuming from offset: ${audioPauseOffset.toFixed(3)}`);
                         }
                     }).catch(e => console.error("Failed to resume AudioContext on play/pause:", e));
                });
            }

            // Settings Button
            if (settingsButton && settingsOverlay && staffModule && audioModule) {
                settingsButton.addEventListener('click', () => {
                    if (isGameOver) return;
                    console.log("Settings button clicked.");
                    // Pause the game first if it's running
                    if (gameIsRunning) {
                        audioPauseOffset = staffModule.pause(); // Pause visuals & audio
                        playPauseButton.textContent = "Play"; // Update main button text
                        gameIsRunning = false;
                        console.log("Paused game for settings.");
                    }
                    updateSettingsUI(); // Ensure UI reflects current state
                    settingsOverlay.classList.add('visible');
                });
            }

            // Close Settings Button
            if (closeSettingsButton && settingsOverlay) {
                closeSettingsButton.addEventListener('click', () => {
                    settingsOverlay.classList.remove('visible');
                    console.log("Settings overlay closed.");
                    // Leave paused. User must press Play again.
                    // Ensure the staff redraws if settings changed while paused
                    if (!gameIsRunning && staffModule) {
                        staffModule.redraw();
                    }
                });
            }

             // Settings: Color Toggle Switch
             if (colorToggleSwitch && staffModule) {
                 colorToggleSwitch.addEventListener('change', (event) => {
                     useColoredNotes = event.target.checked;
                     console.log(`Color notes setting changed: ${useColoredNotes}`);
                     staffModule.redraw(); // Immediately redraw
                 });
             }

             // Settings: No Death Mode Toggle Switch
             if (noDeathToggleSwitch) {
                 noDeathToggleSwitch.addEventListener('change', (event) => {
                     noDeathMode = event.target.checked;
                     console.log(`No Death Mode setting changed: ${noDeathMode}`);
                 });
             }

             // Settings: Staff Scale Adjustment
             const STAFF_SCALE_STEP = 10;
             const STAFF_SCALE_MIN = 50;
             const STAFF_SCALE_MAX = 200;
             if (staffScaleDownButton) {
                 staffScaleDownButton.addEventListener('click', () => {
                     SCROLL_SPEED_PIXELS_PER_SECOND = Math.max(STAFF_SCALE_MIN, SCROLL_SPEED_PIXELS_PER_SECOND - STAFF_SCALE_STEP);
                     updateSettingsUI();
                     staffModule.redraw();
                 });
             }
             if (staffScaleUpButton) {
                 staffScaleUpButton.addEventListener('click', () => {
                     SCROLL_SPEED_PIXELS_PER_SECOND = Math.min(STAFF_SCALE_MAX, SCROLL_SPEED_PIXELS_PER_SECOND + STAFF_SCALE_STEP);
                     updateSettingsUI();
                     staffModule.redraw();
                 });
             }

             // Settings: Hit Window Adjustment
             const HIT_WINDOW_STEP = 5;
             const HIT_WINDOW_MIN = 30; // Min Good window (Perfect will be 15)
             const HIT_WINDOW_MAX = 200; // Increase max to allow 140 default
             if (hitWindowDownButton) {
                 hitWindowDownButton.addEventListener('click', () => {
                     HIT_WINDOW_GOOD_MS = Math.max(HIT_WINDOW_MIN, HIT_WINDOW_GOOD_MS - HIT_WINDOW_STEP);
                     updateSettingsUI(); // Calls updateTimingWindows
                 });
             }
              if (hitWindowUpButton) {
                 hitWindowUpButton.addEventListener('click', () => {
                     HIT_WINDOW_GOOD_MS = Math.min(HIT_WINDOW_MAX, HIT_WINDOW_GOOD_MS + HIT_WINDOW_STEP);
                     updateSettingsUI(); // Calls updateTimingWindows
                 });
             }


             // Score Screen: Restart Button
             if (restartButton) {
                 // Remove previous listener if any (to prevent duplicates if init runs again)
                 const newRestartButton = restartButton.cloneNode(true);
                 restartButton.parentNode.replaceChild(newRestartButton, restartButton);
                 newRestartButton.addEventListener('click', restartGame);
             }

            // Orientation Change Listener
            window.matchMedia("(orientation: landscape)").addEventListener("change", handleLayoutChange);

            // Window Resize Listener (Debounced)
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    handleLayoutChange();
                }, 150);
            });

            gameInitialized = true;
            console.log("--- Keytap Game Initialization Complete ---");
            loadingStatus.textContent = "Ready!"; // Or clear the status
        }

        // --- File Loading Logic ---

        /** Checks if both files are loaded and updates the start button state */
        function checkFilesLoaded() {
            if (audioFileLoaded && notesFileLoaded) {
                loadingStatus.textContent = "Files loaded. Ready to start!";
                startButton.disabled = false;
                console.log("Both files loaded and validated.");
            } else {
                startButton.disabled = true;
                // Update status based on which file is missing
                if (!audioFileLoaded && !notesFileLoaded) {
                    loadingStatus.textContent = "Please select both files.";
                } else if (!audioFileLoaded) {
                    loadingStatus.textContent = "Please select an MP3 audio file.";
                } else {
                    loadingStatus.textContent = "Please select a JSON notes file.";
                }
            }
        }

        /** Handles audio file selection */
        function handleAudioFileSelect(event) {
            const file = event.target.files[0];
            if (!file) {
                audioFileLoaded = false;
                audioFileBuffer = null;
                checkFilesLoaded();
                return;
            }

            // Basic type check (more robust checks can be added)
            if (!file.type.startsWith('audio/mpeg') && !file.name.toLowerCase().endsWith('.mp3')) {
                alert("Invalid audio file type. Please select an MP3 file.");
                event.target.value = ''; // Clear the input
                audioFileLoaded = false;
                audioFileBuffer = null;
                checkFilesLoaded();
                return;
            }

            loadingStatus.textContent = "Loading audio file...";
            startButton.disabled = true; // Disable while loading

            const reader = new FileReader();
            reader.onload = (e) => {
                audioFileBuffer = e.target.result; // Store ArrayBuffer
                audioFileLoaded = true;
                console.log("Audio file loaded into ArrayBuffer.");
                checkFilesLoaded();
            };
            reader.onerror = (e) => {
                console.error("Error reading audio file:", e);
                alert("Error reading audio file.");
                audioFileLoaded = false;
                audioFileBuffer = null;
                checkFilesLoaded();
            };
            reader.readAsArrayBuffer(file);
        }

        /** Handles notes file selection */
        function handleNotesFileSelect(event) {
            const file = event.target.files[0];
            if (!file) {
                notesFileLoaded = false;
                notesJsonData = null;
                checkFilesLoaded();
                return;
            }

            // Basic type check
             if (!file.type.startsWith('application/json') && !file.name.toLowerCase().endsWith('.json')) {
                alert("Invalid notes file type. Please select a JSON file.");
                event.target.value = ''; // Clear the input
                notesFileLoaded = false;
                notesJsonData = null;
                checkFilesLoaded();
                return;
            }

            loadingStatus.textContent = "Loading notes file...";
            startButton.disabled = true; // Disable while loading

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    notesJsonData = JSON.parse(e.target.result); // Parse JSON text
                    // Basic validation of JSON structure (can be expanded)
                    if (!notesJsonData || !notesJsonData.tracks || !Array.isArray(notesJsonData.tracks)) {
                         throw new Error("Invalid JSON structure: Missing 'tracks' array.");
                    }
                    notesFileLoaded = true;
                    console.log("Notes file loaded and parsed successfully.");
                    checkFilesLoaded();
                } catch (error) {
                    console.error("Error parsing JSON file:", error);
                    alert(`Error parsing JSON file: ${error.message}`);
                    notesFileLoaded = false;
                    notesJsonData = null;
                    checkFilesLoaded();
                }
            };
            reader.onerror = (e) => {
                console.error("Error reading notes file:", e);
                alert("Error reading notes file.");
                notesFileLoaded = false;
                notesJsonData = null;
                checkFilesLoaded();
            };
            reader.readAsText(file);
        }

        // --- Entry Point & Loading Screen Setup ---
        window.addEventListener('load', () => {
            console.log("Window loaded. Setting up file inputs.");

            if (!audioFileInput || !notesFileInput || !startButton || !loadingScreen || !gameContainer) {
                console.error("CRITICAL: Loading screen or game container elements not found!");
                alert("Error: Could not initialize the game interface.");
                return;
            }

            // Add file input listeners
            audioFileInput.addEventListener('change', handleAudioFileSelect);
            notesFileInput.addEventListener('change', handleNotesFileSelect);

            // Add start button listener
            startButton.addEventListener('click', async () => {
                if (audioFileLoaded && notesFileLoaded) {
                    console.log("Start button clicked. Hiding loading screen.");
                    startButton.disabled = true; // Prevent double clicks
                    loadingStatus.textContent = "Starting game...";

                    // Hide loading screen and show game container
                    loadingScreen.classList.add('hidden');
                    gameContainer.classList.add('visible'); // Make game container visible

                    // Initialize the game with the loaded data
                    await initializeGame(audioFileBuffer, notesJsonData);
                } else {
                    console.warn("Start button clicked but files not ready.");
                    checkFilesLoaded(); // Update status message
                }
            });

            // Initial check in case files are pre-selected (e.g., browser refresh)
            // Also call updateTimingWindows initially to set derived values from defaults
            updateTimingWindows();
            checkFilesLoaded();
        });
        console.log("Global: window.onload event listener added for loading screen setup.");

    </script>

</body>
</html>
