<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Keytap - Game</title>
    <script src="//cdn.jsdelivr.net/npm/eruda"></script>
    <script src="https://cdn.jsdelivr.net/gh/JotaGreen/keytap@main/midiColorConverter.js"></script>
    <style>
        /* Apply border-box sizing globally for easier layout */
        * {
            box-sizing: border-box;
            /* Disable user selection globally, can be re-enabled for specific elements if needed */
            user-select: none;
            -webkit-user-select: none; /* Safari */
            -moz-user-select: none; /* Firefox */
            -ms-user-select: none; /* IE */
            /* Prevent callout menu on long press (iOS) */
            -webkit-touch-callout: none;
            /* Improve touch interaction responsiveness */
            touch-action: manipulation; /* Allows pinch-zoom, prevents double-tap zoom */
        }

        /* Basic body styling */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* Prevent scrollbars on the body */
            background-color: #f0f0f0; /* Light grey background */
            font-family: sans-serif; /* Simple sans-serif font */
            /* Prevent pull-to-refresh and other unwanted touch behaviors */
            overscroll-behavior: none;
        }

        /* Main game container - Full viewport, column layout by default (portrait) */
        #gameContainer {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column; /* Default to portrait layout */
            background-color: #e0e0e0; /* Slightly darker grey for container */
        }

        /* --- Layout Sections --- */
        #infoSection {
            background-color: #d0d0d0; /* Slightly lighter grey */
            padding: 5px 10px;
            display: flex;
            flex-direction: column; /* Stack top row and health bar */
            justify-content: center; /* Center content vertically */
            flex-shrink: 0; /* Prevent shrinking */
            border-bottom: 1px solid #b0b0b0;
            overflow: hidden; /* Hide overflow */
        }
        #infoTopRow {
            display: flex;
            justify-content: space-between; /* Space out controls and combo */
            align-items: center;
            width: 100%;
            margin-bottom: 5px; /* Space between top row and health bar */
        }
        #controlsContainer {
             display: flex;
             gap: clamp(4px, 1.5vmin, 8px); /* Responsive gap */
             align-items: center; /* Align buttons and combo text */
        }
        #comboDisplay {
            font-size: clamp(0.8em, 2.8vmin, 1.1em); /* Responsive font size */
            font-weight: bold;
            color: #333;
            white-space: nowrap; /* Prevent wrapping */
            margin-left: 10px; /* Space from buttons */
        }
        #healthBarContainer {
            width: 100%;
            height: clamp(10px, 3vmin, 15px); /* Responsive height */
            background-color: #a0a0a0; /* Darker background for the bar */
            border-radius: 5px;
            border: 1px solid #888;
            overflow: hidden; /* Keep the inner bar contained */
            position: relative; /* For potential text overlay later */
        }
        #healthBar {
            width: 66.66%; /* Start at 50/75 health */
            height: 100%;
            background-color: #4CAF50; /* Green health */
            border-radius: 4px; /* Slightly smaller radius than container */
            transition: width 0.3s ease-out, background-color 0.3s ease-out; /* Smooth transition for health changes */
        }

        #staffSection {
            background-color: #ffffff; /* White background for the staff area */
            flex-grow: 1; /* Takes up remaining space in column layout */
            overflow: hidden; /* Hide canvas overflow */
            position: relative; /* Needed for canvas positioning/sizing */
            display: flex; /* Use flex to center canvas */
            justify-content: center;
            align-items: center; /* Center canvas vertically */
            border-bottom: 1px solid #b0b0b0; /* Add border for separation */
        }

        /* Container for bottom elements in landscape mode */
        #bottomPanel {
            display: flex; /* Will be row in landscape */
            flex-shrink: 0;
            /* Border is handled by staffSection bottom and infoSection right */
        }

        #keyboardSection {
            background-color: #c0c0c0; /* Even lighter grey */
            display: flex;
            justify-content: center; /* Center the piano horizontally */
            align-items: center; /* Center the piano vertically */
            padding: 5px 0; /* Add some vertical padding */
            flex-shrink: 0; /* Prevent shrinking */
            overflow: hidden; /* Hide overflow */
        }

        /* --- Responsive Layout --- */

        /* Portrait Mode (Default - Mobile First) */
        #infoSection {
            order: 1;
            height: 15%; /* Top 15% */
            border-bottom: 1px solid #b0b0b0; /* Ensure border exists */
        }
        #staffSection {
            order: 2;
            height: 50%; /* Middle 50% */
            border-bottom: 1px solid #b0b0b0; /* Ensure border exists */
        }
        #bottomPanel { /* Contains only keyboard in portrait */
            order: 3;
            height: 35%; /* Bottom 35% */
            border-top: none; /* Remove top border, staffSection has bottom border */
            flex-direction: column; /* Stack elements vertically (only keyboard here) */
        }
         #keyboardSection {
             width: 100%; /* Full width */
             height: 100%; /* Full height of bottomPanel */
             border-left: none; /* No side borders */
         }


        /* Landscape Mode */
        @media (orientation: landscape) {
            #gameContainer {
                /* Still column overall: Staff on top, BottomPanel below */
                flex-direction: column;
            }

            #staffSection {
                order: 1; /* Staff comes first */
                height: 66.66%; /* Top 2/3 */
                width: 100%; /* Full width */
                border-bottom: 1px solid #b0b0b0; /* Keep bottom border */
            }

            #bottomPanel {
                order: 2; /* Panel comes second */
                height: 33.33%; /* Bottom 1/3 */
                width: 100%;
                flex-direction: row; /* Arrange info and keyboard side-by-side */
                border-top: none; /* Remove top border, staffSection has bottom border */
            }

             #infoSection {
                order: 1; /* Info is inside bottom panel, comes first */
                width: 50%; /* Left half of bottom panel */
                height: 100%; /* Full height of bottom panel */
                border-bottom: none; /* No bottom border */
                border-right: 1px solid #b0b0b0; /* Add border between info and keyboard */
                justify-content: center; /* Center content vertically */
            }

            #keyboardSection {
                order: 2; /* Keyboard is inside bottom panel, comes second */
                width: 50%; /* Right half of bottom panel */
                height: 100%; /* Full height of bottom panel */
                padding: 10px 5px; /* Adjust padding */
                border-left: none; /* Remove left border (infoSection has right border) */
            }
        }

        /* --- Staff Canvas Styling --- */
        #staffCanvas {
            background-color: #ffffff; /* White background for the staff */
            display: block; /* Remove extra space below canvas */
            /* Let container size it, but set max limits */
            max-width: 100%;
            max-height: 100%;
            /* Border is now on the container (#staffSection) */
            box-sizing: border-box;
            cursor: grab; /* Indicate draggable when paused */
        }
        #staffCanvas.dragging {
             cursor: grabbing; /* Change cursor during drag */
        }

        /* --- Piano Keyboard Styling --- */
        .piano {
            display: flex; /* Use flexbox for key layout */
            position: relative; /* Needed for positioning black keys */
            padding: 0; /* No internal padding */
            /* Let flexbox size it within keyboardSection */
            width: 95%; /* Take most of the width */
            height: 90%; /* Take most of the height */
            max-width: 600px; /* Max width constraint */
            max-height: 240px; /* Max height constraint */
            background-color: transparent; /* Ensure no background */
            border: 1px solid #999; /* Add a light border for visual structure */
            box-shadow: 0 4px 10px rgba(0,0,0,0.15); /* Add a subtle shadow to the container */
            border-radius: 5px; /* Slightly round the container corners */
            overflow: hidden; /* Hide anything poking out */
        }

        .key {
            border: 1px solid #555; /* Border for definition */
            border-top: none; /* No top border on any key */
            border-radius: 0 0 5px 5px; /* Rounded bottom corners */
            cursor: pointer; /* Indicate interactivity */
            transition: background-color 0.1s ease, box-shadow 0.1s ease; /* Smooth transitions */
            box-shadow: 0 2px 3px rgba(0,0,0,0.2); /* Subtle shadow */
            touch-action: none; /* Prevent default touch actions like scrolling when interacting with keys */
        }

        .white {
            /* Use flex-grow to distribute space, height relative to container */
            flex-grow: 1;
            height: 100%;
            min-width: 30px; /* Minimum width */
            background-color: #fff; /* White color */
            z-index: 1; /* White keys behind black keys */
            border-right: none; /* Remove right border to create seamless look */
            border-left: none; /* Remove left border */
        }
        /* Add left border back to the first white key */
        .white:first-child {
            border-left: 1px solid #555;
            border-radius: 0 0 0 5px; /* Adjust rounding for first key */
        }
         /* Add right border back to the last white key */
        .white:last-child {
             border-right: 1px solid #555;
             border-radius: 0 0 5px 0; /* Adjust rounding for last key */
        }

        .black {
            /* Width relative to white keys, height relative to piano container */
            width: 60%; /* Percentage of the white key it overlaps */
            height: 60%; /* Percentage of the piano container height */
            max-width: 38px; /* Max width constraint */
            max-height: 140px; /* Max height constraint */
            background-color: #222; /* Black color */
            position: absolute; /* Position relative to the piano container */
            z-index: 2; /* Black keys on top */
            border: 1px solid #333; /* Slightly darker border for black keys */
            border-top: none; /* No top border */
            border-radius: 0 0 3px 3px; /* Slightly different rounding */
            box-shadow: -1px 0 2px rgba(255,255,255,0.2) inset, 0 -2px 2px rgba(0,0,0,0.4) inset, 0 2px 3px rgba(0,0,0,0.4); /* More refined shadow */
            /* Center the key horizontally AT the specified 'left' position */
            transform: translateX(-50%);
        }

        /* Positioning for specific black keys - based on percentage of total piano width */
        .black[data-key="Db"] { left: 14.28%; }  /* Gap C-D */
        .black[data-key="Eb"] { left: 28.57%; } /* Gap D-E */
        .black[data-key="Gb"] { left: 57.14%; } /* Gap F-G */
        .black[data-key="Ab"] { left: 71.42%; } /* Gap G-A */
        .black[data-key="Bb"] { left: 85.71%; } /* Gap A-B */

        /* Style for pressed keys */
        .key.pressed {
            background-color: #e0e0e0; /* Slightly darker gray for pressed white */
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.3); /* Inset shadow for pressed effect */
        }
        .black.key.pressed {
            background-color: #444; /* Lighter black for pressed black keys */
            box-shadow: inset -1px 0 2px rgba(255,255,255,0.1), inset 0 -1px 2px rgba(0,0,0,0.3), inset 0 1px 2px rgba(0,0,0,0.5);
        }

        /* --- Info Section Elements Styling --- */
        .control-button {
            /* Basic button styling */
            padding: clamp(4px, 1.2vmin, 6px) clamp(8px, 2.2vmin, 12px); /* Responsive padding */
            font-size: clamp(0.75em, 2.2vmin, 1em); /* Responsive font size */
            cursor: pointer;
            border-radius: 5px;
            border: 1px solid #888;
            background-color: #e8e8e8; /* Slightly lighter button */
            white-space: nowrap; /* Prevent wrapping */
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            line-height: 1; /* Ensure consistent height */
        }
        .control-button:hover {
            background-color: #d8d8d8;
        }
         .control-button:active {
             box-shadow: inset 0 1px 2px rgba(0,0,0,0.15);
             transform: translateY(1px);
         }
         /* Style for disabled buttons */
        .control-button:disabled {
            background-color: #cccccc;
            color: #888888;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        /* --- Overlay Common Styles --- */
        .overlay {
            position: fixed; /* Cover the whole screen */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6); /* Semi-transparent black background */
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
            z-index: 1000; /* Ensure it's on top */
            padding: 15px; /* Padding around the panel */
        }
        .overlay.visible {
            display: flex; /* Show when visible class is added */
        }
        .overlay-panel {
            background-color: #f0f0f0;
            padding: 20px 30px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            min-width: 280px; /* Slightly wider for new controls */
            max-width: 90%;
            max-height: 90vh; /* Prevent panel from being too tall */
            overflow-y: auto; /* Add scroll if content overflows */
            display: flex;
            flex-direction: column;
            gap: 15px; /* Spacing between elements */
        }
        .overlay-panel h2 {
            margin: 0 0 10px 0;
            text-align: center;
            color: #333;
        }

        /* --- Settings Overlay Specific Styles --- */
        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px; /* Add gap between label and control */
        }
        .setting-item label {
            /* margin-right: 15px; Replaced by gap */
            color: #444;
            white-space: nowrap; /* Prevent label wrapping */
        }
        .setting-control {
            display: flex;
            align-items: center;
            gap: 5px; /* Gap between buttons and value */
        }
        .setting-value {
            min-width: 40px; /* Ensure space for value */
            text-align: right;
            font-weight: bold;
            color: #333;
        }
        .adjust-button {
            font-weight: bold;
            padding: 2px 6px; /* Smaller padding */
            font-size: 0.9em;
            min-width: 25px; /* Ensure buttons have some width */
            line-height: 1;
        }

        /* Basic Toggle Switch Styling */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px; /* Width of the switch */
            height: 24px; /* Height of the switch */
            flex-shrink: 0; /* Prevent switch from shrinking */
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px; /* Make it rounded */
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 18px; /* Size of the knob */
            width: 18px;
            left: 3px; /* Padding from left */
            bottom: 3px; /* Padding from bottom */
            background-color: white;
            transition: .4s;
            border-radius: 50%; /* Make it circular */
        }
        input:checked + .slider {
            background-color: #4CAF50; /* Green when checked */
        }
        input:checked + .slider:before {
            transform: translateX(26px); /* Move knob to the right */
        }
        #closeSettingsButton {
            align-self: center; /* Center the close button */
            margin-top: 10px;
        }

        /* --- Score Overlay Specific Styles --- */
        #scoreStats {
            display: grid;
            grid-template-columns: auto 1fr; /* Label and value columns */
            gap: 5px 15px; /* Row gap, Column gap */
            align-items: center;
        }
        #scoreStats dt { /* Definition Term (Label) */
            font-weight: bold;
            text-align: right;
            color: #555;
        }
        #scoreStats dd { /* Definition Description (Value) */
            margin: 0; /* Reset default margin */
            text-align: left;
        }
        #restartButton {
             align-self: center; /* Center the restart button */
             margin-top: 15px;
        }

    </style>
</head>
<body>

    <div id="gameContainer">
        <div id="infoSection">
            <div id="infoTopRow">
                <div id="controlsContainer">
                     <button id="playPauseButton" class="control-button">Play</button>
                     <button id="settingsButton" class="control-button">Settings</button>
                     <div id="comboDisplay">Combo: <span id="comboCount">0</span></div>
                </div>
            </div>
             <div id="healthBarContainer">
                <div id="healthBar"></div>
            </div>
        </div>

        <div id="staffSection">
            <canvas id="staffCanvas"></canvas>
        </div>

        <div id="bottomPanel">
             <div id="keyboardSection">
                 <div class="piano" id="piano">
                     <div class="key white" data-key="C"></div>
                     <div class="key white" data-key="D"></div>
                     <div class="key white" data-key="E"></div>
                     <div class="key white" data-key="F"></div>
                     <div class="key white" data-key="G"></div>
                     <div class="key white" data-key="A"></div>
                     <div class="key white" data-key="B"></div>
                     <div class="key black" data-key="Db"></div>
                     <div class="key black" data-key="Eb"></div>
                     <div class="key black" data-key="Gb"></div>
                     <div class="key black" data-key="Ab"></div>
                     <div class="key black" data-key="Bb"></div>
                 </div>
             </div>
        </div>
    </div>

    <div id="settingsOverlay" class="overlay">
        <div id="settingsPanel" class="overlay-panel">
            <h2>Settings</h2>
            <div class="setting-item">
                <label for="staffScaleValue">Staff Scale (px/s)</label>
                <div class="setting-control">
                    <button id="staffScaleDown" class="control-button adjust-button">-</button>
                    <span id="staffScaleValue" class="setting-value">100</span>
                    <button id="staffScaleUp" class="control-button adjust-button">+</button>
                </div>
            </div>
             <div class="setting-item">
                <label for="hitWindowValue">Hit Window (ms)</label>
                 <div class="setting-control">
                    <button id="hitWindowDown" class="control-button adjust-button">-</button>
                    <span id="hitWindowValue" class="setting-value">70</span>
                    <button id="hitWindowUp" class="control-button adjust-button">+</button>
                </div>
            </div>
            <div class="setting-item">
                <label for="colorToggleSwitch">Color Notes</label>
                 <div class="setting-control">
                     <label class="toggle-switch">
                         <input type="checkbox" id="colorToggleSwitch">
                         <span class="slider"></span>
                     </label>
                 </div>
            </div>
             <div class="setting-item">
                <label for="noDeathToggleSwitch">No Death Mode</label>
                 <div class="setting-control">
                     <label class="toggle-switch">
                         <input type="checkbox" id="noDeathToggleSwitch">
                         <span class="slider"></span>
                     </label>
                 </div>
            </div>
            <button id="closeSettingsButton" class="control-button">Close</button>
        </div>
    </div>

    <div id="scoreOverlay" class="overlay">
        <div id="scorePanel" class="overlay-panel">
            <h2>Results</h2>
            <dl id="scoreStats">
                <dt>Perfect:</dt> <dd><span id="scorePerfectCount">0</span> (<span id="scorePerfectPercent">0</span>%)</dd>
                <dt>Good:</dt>    <dd><span id="scoreGoodCount">0</span> (<span id="scoreGoodPercent">0</span>%)</dd>
                <dt>Miss:</dt>     <dd><span id="scoreMissCount">0</span> (<span id="scoreMissPercent">0</span>%)</dd>
                <dt>Max Combo:</dt><dd><span id="scoreMaxCombo">0</span></dd>
                <dt>Score:</dt>    <dd><span id="scoreTotalScore">0</span></dd>
            </dl>
            <button id="restartButton" class="control-button">Restart</button>
        </div>
    </div>


    <script>
        console.log("Keytap Game script starting execution.");

        // --- Initialize Eruda ---
        try {
            if (typeof eruda !== 'undefined') {
                eruda.init();
                console.log("Eruda initialized.");
            } else { console.warn("Eruda not found."); }
        } catch (e) { console.error("Failed to initialize Eruda:", e); }

        // --- Game Settings & State ---
        const INITIAL_HEALTH = 50;
        const MAX_HEALTH = 75;
        const MIN_HEALTH = 0;
        // Default values
        let SCROLL_SPEED_PIXELS_PER_SECOND = 100;
        let HIT_WINDOW_GOOD_MS = 70;
        // Derived timing values (will be updated when HIT_WINDOW_GOOD_MS changes)
        let HIT_WINDOW_PERFECT_MS = HIT_WINDOW_GOOD_MS / 2;
        let HIT_WINDOW_GOOD_SEC = HIT_WINDOW_GOOD_MS / 1000.0;
        let HIT_WINDOW_PERFECT_SEC = HIT_WINDOW_PERFECT_MS / 1000.0;
        // Other state
        let comboCount = 0;
        let playerHealth = INITIAL_HEALTH;
        let totalScore = 0; // Track cumulative score
        let perfectCount = 0;
        let goodCount = 0;
        let missCount = 0;
        let maxCombo = 0;
        let totalNotesInSong = 0; // Will be set when notes are loaded
        let useColoredNotes = false; // Initial state for color setting
        let noDeathMode = false; // Initial state for no death mode
        let gameIsRunning = false; // Global flag for overall game state (paused/playing)
        let isGameOver = false; // Flag for game over state

        // --- Global DOM Elements ---
        const gameContainer = document.getElementById('gameContainer');
        const infoSection = document.getElementById('infoSection');
        const staffSection = document.getElementById('staffSection');
        const bottomPanel = document.getElementById('bottomPanel');
        const keyboardSection = document.getElementById('keyboardSection');
        // Info Section Elements
        const playPauseButton = document.getElementById('playPauseButton'); // Main Play/Pause
        const settingsButton = document.getElementById('settingsButton');
        const comboCountSpan = document.getElementById('comboCount');
        const healthBarElement = document.getElementById('healthBar');
        // Settings Overlay Elements
        const settingsOverlay = document.getElementById('settingsOverlay');
        const colorToggleSwitch = document.getElementById('colorToggleSwitch');
        const noDeathToggleSwitch = document.getElementById('noDeathToggleSwitch');
        const closeSettingsButton = document.getElementById('closeSettingsButton');
        const staffScaleValueSpan = document.getElementById('staffScaleValue');
        const staffScaleDownButton = document.getElementById('staffScaleDown');
        const staffScaleUpButton = document.getElementById('staffScaleUp');
        const hitWindowValueSpan = document.getElementById('hitWindowValue');
        const hitWindowDownButton = document.getElementById('hitWindowDown');
        const hitWindowUpButton = document.getElementById('hitWindowUp');
        // Score Overlay Elements
        const scoreOverlay = document.getElementById('scoreOverlay');
        const scorePerfectCount = document.getElementById('scorePerfectCount');
        const scorePerfectPercent = document.getElementById('scorePerfectPercent');
        const scoreGoodCount = document.getElementById('scoreGoodCount');
        const scoreGoodPercent = document.getElementById('scoreGoodPercent');
        const scoreMissCount = document.getElementById('scoreMissCount');
        const scoreMissPercent = document.getElementById('scoreMissPercent');
        const scoreMaxCombo = document.getElementById('scoreMaxCombo');
        const scoreTotalScore = document.getElementById('scoreTotalScore');
        const restartButton = document.getElementById('restartButton');


        // --- Scoring Constants ---
        const ENERGY_PERFECT = 2;
        const ENERGY_GOOD = 0; // No base energy for good hits
        const ENERGY_MISS = -10;

        /**
         * Calculates the combo bonus energy based on the current combo count.
         * @param {number} currentCombo - The current combo count.
         * @returns {number} The additional energy awarded as a combo bonus.
         */
        function calculateComboBonus(currentCombo) {
            if (currentCombo < 10) {
                return 0;
            }
            // Calculate bonus tiers: 10-19 -> +1, 20-29 -> +2, etc.
            const bonus = Math.floor((currentCombo - 1) / 10); // -1 ensures 10-19 is tier 1, 20-29 tier 2 etc.
            return bonus;
        }

        /**
         * Applies scoring changes based on hit type or miss.
         * Updates playerHealth, comboCount, totalScore, maxCombo, and hit counts.
         * @param {'perfect' | 'good' | 'miss'} hitType - The type of hit or miss.
         */
        function applyScore(hitType) {
            if (isGameOver) return; // Don't apply score changes if game is already over

            let baseEnergyChange = 0;
            let comboBroken = false;

            if (hitType === 'perfect') {
                perfectCount++;
                comboCount++;
                baseEnergyChange = ENERGY_PERFECT;
            } else if (hitType === 'good') {
                goodCount++;
                comboCount++;
                baseEnergyChange = ENERGY_GOOD; // Still increments combo
            } else if (hitType === 'miss') {
                missCount++;
                comboBroken = true;
                baseEnergyChange = ENERGY_MISS;
            }

            // Update Max Combo
            if (comboCount > maxCombo) {
                maxCombo = comboCount;
            }

            // Calculate combo bonus only if the combo wasn't broken
            const comboBonus = comboBroken ? 0 : calculateComboBonus(comboCount);
            const totalEnergyChange = baseEnergyChange + comboBonus;

            // Update Player Health (clamped)
            const previousHealth = playerHealth;
            playerHealth = Math.max(MIN_HEALTH, Math.min(MAX_HEALTH, playerHealth + totalEnergyChange));
            const actualHealthChange = playerHealth - previousHealth; // How much health actually changed after clamping

            // Update Total Score (Gain - Loss)
            totalScore += totalEnergyChange; // Add the raw change (can be negative)

            // Reset combo if broken
            if (comboBroken) {
                if (comboCount > 0) { // Only log if combo was actually broken
                     console.log(`Combo Broken! Was: ${comboCount}`);
                     comboCount = 0;
                }
            }

            console.log(`Score Event: ${hitType.toUpperCase()} | Combo: ${comboCount} (Max: ${maxCombo}) | Health Change: ${actualHealthChange} (Raw: ${totalEnergyChange}) | Health: ${playerHealth}/${MAX_HEALTH} | Score: ${totalScore} | P:${perfectCount} G:${goodCount} M:${missCount}`);

            // Update the UI
            updateInfoUI();

            // Check for Game Over AFTER updating UI
            if (playerHealth <= MIN_HEALTH && !isGameOver) {
                 // Check No Death Mode setting
                 if (!noDeathMode) {
                     triggerGameOver(false); // Pass false indicating it wasn't a song finish
                 } else {
                     console.log("Health reached zero, but No Death Mode is active.");
                     // Keep playing, health stays at 0
                 }
            }
        }

        /**
         * Handles the game over state or song completion.
         * @param {boolean} songFinished - True if triggered by song end, false if by death.
         */
        function triggerGameOver(songFinished) {
            if (isGameOver) return; // Prevent multiple triggers

            console.log(songFinished ? "--- SONG FINISHED ---" : "--- GAME OVER ---");
            isGameOver = true;
            gameIsRunning = false; // Ensure game state is set to not running

            // Pause the staff module if it exists and is running
            if (staffModule && staffModule.isRunning()) {
                staffModule.pause();
            }
            // Update button text and disable interactions
            playPauseButton.textContent = songFinished ? "Finished" : "Game Over";
            playPauseButton.disabled = true;
            settingsButton.disabled = true;

            // Show the score screen
            showScoreScreen();
        }

        /** Calculates and displays the final score screen */
        function showScoreScreen() {
            if (!scoreOverlay) return;

            const processedNotes = perfectCount + goodCount + missCount;
            // Use totalNotesInSong if available and greater than 0, otherwise use processedNotes
            const totalNotes = totalNotesInSong > 0 ? totalNotesInSong : processedNotes;

            // Calculate percentages (handle division by zero)
            const perfectPercent = totalNotes > 0 ? ((perfectCount / totalNotes) * 100).toFixed(1) : 0;
            const goodPercent = totalNotes > 0 ? ((goodCount / totalNotes) * 100).toFixed(1) : 0;
            const missPercent = totalNotes > 0 ? ((missCount / totalNotes) * 100).toFixed(1) : 0;

            // Update DOM elements
            scorePerfectCount.textContent = perfectCount;
            scorePerfectPercent.textContent = perfectPercent;
            scoreGoodCount.textContent = goodCount;
            scoreGoodPercent.textContent = goodPercent;
            scoreMissCount.textContent = missCount;
            scoreMissPercent.textContent = missPercent;
            scoreMaxCombo.textContent = maxCombo;
            scoreTotalScore.textContent = totalScore;

            // Make overlay visible
            scoreOverlay.classList.add('visible');
            console.log("Score screen displayed.");
        }

        /** Resets the game state to its initial values */
        function restartGame() {
            console.log("--- Restarting Game ---");

            // Hide Score Overlay
            if (scoreOverlay) {
                scoreOverlay.classList.remove('visible');
            }

            // Reset Game State Variables
            playerHealth = INITIAL_HEALTH;
            comboCount = 0;
            totalScore = 0;
            perfectCount = 0;
            goodCount = 0;
            missCount = 0;
            maxCombo = 0;
            isGameOver = false;
            gameIsRunning = false; // Start paused

            // Reset Staff Module State (if possible)
            if (staffModule) {
                staffModule.resetNotes(); // Reset hit status for all notes
                staffModule.resetTime();  // Reset displayTime to start
                staffModule.pause();      // Ensure it's paused
                staffModule.redraw();     // Redraw initial state
            }

            // Reset UI
            updateInfoUI();
            playPauseButton.textContent = "Play";
            playPauseButton.disabled = false;
            settingsButton.disabled = false;

            console.log("Game state reset.");
        }


        // --- Staff Component Logic ---
        const staffModule = (() => {
            console.log("Initializing Staff Module...");

            // --- Configuration Constants ---
            // Note: SCROLL_SPEED_PIXELS_PER_SECOND and HIT_WINDOW variables are now global
            const PRE_DELAY_SECONDS = 1.0;
            const STAFF_LINE_COLOR = '#000000';
            const NOTE_COLOR = '#333333'; // Default note color (black notes mode)
            const ACCIDENTAL_COLOR_BLACK_NOTES = '#888888'; // Gray for accidentals when notes are black
            const ACCIDENTAL_COLOR_COLOR_NOTES = '#000000'; // Black for accidentals when notes are colored
            const STAFF_LINE_WIDTH = 1;
            const NOTE_CORNER_RADIUS = 3;
            const LINE_SPACING = 12; // Base spacing, affects height
            const STAFF_PADDING = LINE_SPACING / 2;
            const JUDGMENT_LINE_COLOR = '#FF0000';
            const JUDGMENT_LINE_WIDTH = 2;
            const JUDGMENT_LINE_X_PERCENT = 20; // Percentage from left
            const MIDI_NOTE_MIN = 36; // C2
            const MIDI_NOTE_MAX = 84; // C6
            const ACCIDENTAL_PADDING_X = 3; // Padding from note start
            const ACCIDENTAL_FONT_SIZE = LINE_SPACING * 1.2;
            const LEDGER_LINE_EXTENSION = 4;
            const LEDGER_LINE_WIDTH = 1;
            const MIN_DISPLAY_TIME = 0.0;
            const NOTE_DATA_URL = 'https://raw.githubusercontent.com/JotaGreen/keytap/refs/heads/main/test.json';
            // Perfect Flash Effect
            const PERFECT_FLASH_COLOR = 'rgba(255, 215, 0, 0.7)'; // Gold, semi-transparent
            const PERFECT_FLASH_DURATION_MS = 150; // How long the flash lasts
            const SONG_END_BUFFER_SEC = 2.0; // How long after the last note ends to trigger song finish

            // --- DOM Elements (Staff Specific) ---
            const canvas = document.getElementById('staffCanvas');

            // --- Canvas Setup ---
            if (!canvas || !staffSection) {
                console.error("Staff Error: Required DOM element (canvas or staffSection) not found!");
                return null; // Stop module initialization
            }
            const ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error("Staff Error: Could not get 2D rendering context!");
                return null;
            }
            const devicePixelRatio = window.devicePixelRatio || 1;
            // console.log(`Staff: Device Pixel Ratio: ${devicePixelRatio}`); // Reduce noise

            let canvasWidth = 300; // Logical display width (updated on resize)
            let canvasHeight = 150; // Logical display height (updated on resize)
            let judgmentLineX; // Logical X position (updated on resize)

            // --- Staff Geometry & Note Position Mapping ---
            // console.log("Staff: Calculating staff line Y positions and note mappings..."); // Reduce noise
            const HALF_LINE_SPACING = LINE_SPACING / 2;
            let totalStaffLogicalHeight = 150; // Calculated height
            const staffPositions = {}; // Holds absolute Y coords for staff lines/spaces
            let diatonicNoteYPositions = {}; // Holds absolute Y coords for note centers
            const midiToDiatonicDegree = [0, 0, 1, 1, 2, 3, 3, 4, 4, 5, 5, 6]; // C=0, D=1, ..., B=6
            const notePitchClasses = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"]; // For matching key presses

            /** Calculates staff geometry, note Y positions, and total canvas height */
            function setupStaffAndNotes() {
                // Relative Y positions (Top line F5 is 0)
                let currentY_rel = 0;
                const staffPositions_rel = {};
                staffPositions_rel.F5 = currentY_rel; // Top line treble
                staffPositions_rel.E5 = staffPositions_rel.F5 + HALF_LINE_SPACING;
                staffPositions_rel.D5 = staffPositions_rel.F5 + LINE_SPACING;
                staffPositions_rel.C5 = staffPositions_rel.D5 + HALF_LINE_SPACING;
                staffPositions_rel.B4 = staffPositions_rel.D5 + LINE_SPACING;
                staffPositions_rel.A4 = staffPositions_rel.B4 + HALF_LINE_SPACING;
                staffPositions_rel.G4 = staffPositions_rel.B4 + LINE_SPACING; // Treble G line
                staffPositions_rel.F4 = staffPositions_rel.G4 + HALF_LINE_SPACING;
                staffPositions_rel.E4 = staffPositions_rel.G4 + LINE_SPACING; // Treble E line
                // Space between staves (equivalent to one line space)
                const spaceBetweenStaves = LINE_SPACING;
                staffPositions_rel.D4 = staffPositions_rel.E4 + HALF_LINE_SPACING; // Middle C space (relative)
                staffPositions_rel.C4 = staffPositions_rel.E4 + LINE_SPACING; // Middle C line (relative)
                staffPositions_rel.B3 = staffPositions_rel.C4 + HALF_LINE_SPACING;
                staffPositions_rel.A3 = staffPositions_rel.C4 + LINE_SPACING; // Bass A line
                staffPositions_rel.G3 = staffPositions_rel.A3 + HALF_LINE_SPACING;
                staffPositions_rel.F3 = staffPositions_rel.A3 + LINE_SPACING; // Bass F line
                staffPositions_rel.E3 = staffPositions_rel.F3 + HALF_LINE_SPACING;
                staffPositions_rel.D3 = staffPositions_rel.F3 + LINE_SPACING; // Bass D line
                staffPositions_rel.C3 = staffPositions_rel.D3 + HALF_LINE_SPACING;
                staffPositions_rel.B2 = staffPositions_rel.D3 + LINE_SPACING; // Bass B line
                staffPositions_rel.A2 = staffPositions_rel.B2 + HALF_LINE_SPACING;
                staffPositions_rel.G2 = staffPositions_rel.B2 + LINE_SPACING; // Bottom line bass

                // Map MIDI notes to Y positions
                const noteNames = ["C", "D", "E", "F", "G", "A", "B"];
                const midiRef = 60; // Middle C (C4)
                const yRef_rel = staffPositions_rel.C4; // Y position of Middle C line
                diatonicNoteYPositions = {};
                let minY_rel = Infinity, maxY_rel = -Infinity;

                for (let midi = MIDI_NOTE_MIN; midi <= MIDI_NOTE_MAX; midi++) {
                    const octave = Math.floor(midi / 12) - 1;
                    const noteIndex = midi % 12;
                    const diatonicDegree = midiToDiatonicDegree[noteIndex]; // 0-6

                    const referenceOctave = Math.floor(midiRef / 12) - 1; // Octave of C4 is 4
                    const octaveDifference = octave - referenceOctave; // How many octaves away from C4

                    // Steps relative to C (0) within an octave
                    const stepsFromRefDegree = diatonicDegree - midiToDiatonicDegree[midiRef % 12]; // midiRef%12 is 0 for C

                    // Total diatonic steps away from C4 line (negative is up, positive is down)
                    const totalDiatonicSteps = octaveDifference * 7 + stepsFromRefDegree;

                    // Calculate Y position relative to C4 line
                    const yPos_rel = yRef_rel - (totalDiatonicSteps * HALF_LINE_SPACING);

                    // Store the position using the base note name (e.g., "C4", "G5")
                    const baseNoteLetter = noteNames[diatonicDegree];
                    const baseNoteName = baseNoteLetter + octave;
                    if (!(baseNoteName in diatonicNoteYPositions)) {
                        diatonicNoteYPositions[baseNoteName] = yPos_rel;
                        minY_rel = Math.min(minY_rel, yPos_rel);
                        maxY_rel = Math.max(maxY_rel, yPos_rel);
                    }
                }
                // console.log("Staff: Relative diatonic note Y positions calculated."); // Reduce noise

                // Calculate total height needed based on highest/lowest note centers + note height + padding
                const noteHeight = LINE_SPACING; // Note height matches line spacing
                const topNoteEdgeY_rel = minY_rel - (noteHeight / 2);
                const bottomNoteEdgeY_rel = maxY_rel + (noteHeight / 2);
                totalStaffLogicalHeight = (bottomNoteEdgeY_rel - topNoteEdgeY_rel) + (STAFF_PADDING * 2);
                totalStaffLogicalHeight = Math.max(100, totalStaffLogicalHeight); // Ensure a minimum height

                // Calculate offset to center the staff vertically within the calculated height
                const yOffset = STAFF_PADDING - topNoteEdgeY_rel;

                // Convert relative Y positions to absolute Y positions within the canvas logical height
                for (const key in staffPositions_rel) {
                    staffPositions[key] = staffPositions_rel[key] + yOffset;
                }
                for (const key in diatonicNoteYPositions) {
                    diatonicNoteYPositions[key] += yOffset;
                }

                console.log(`Staff: Precise Total Staff Logical Height Calculated (Padding: ${STAFF_PADDING.toFixed(1)}px): ${totalStaffLogicalHeight.toFixed(1)}px`);
            }
            setupStaffAndNotes(); // Calculate staff geometry and total height once

            // --- Note Data Storage ---
            let noteMap = null;
            let notesToDraw = []; // Will contain notes with { ..., y: number, hitStatus: null | 'good' | 'perfect' | 'miss' }
            let songEndTime = 0; // Time when the last note finishes + buffer

            // --- State Variables ---
            let isStaffRunning = false; // Internal state for staff animation loop
            let animationFrameId = null;
            let displayTime = PRE_DELAY_SECONDS; // Current visual time offset from audio time
            let lastTimestamp = 0; // For calculating delta time
            let isDragging = false;
            let dragStartX = 0;
            let dragStartTime = 0;
            let activeFlashes = []; // To store { y: number, endTime: number } for perfect hit flashes

            // --- Note Y Position Lookup Function ---
            function getNoteYPosition(noteName) {
                const baseNameMatch = noteName.match(/([A-G])[#b]?(\d)/);
                if (baseNameMatch) {
                    const baseName = baseNameMatch[1] + baseNameMatch[2];
                    const yPosition = diatonicNoteYPositions[baseName];
                    return (yPosition !== undefined) ? yPosition : null;
                } else {
                    console.warn(`Staff: Could not parse base note name from: "${noteName}"`);
                    return null;
                }
            }

            // --- Helper: Get Pitch Class from Note Name ---
            function getPitchClass(noteName) {
                const match = noteName.match(/([A-G][#b]?)/);
                if (match) {
                    let pc = match[1];
                    // Simple normalization (can be improved with key signature later)
                    if (pc === "C#") pc = "Db";
                    if (pc === "D#") pc = "Eb";
                    if (pc === "F#") pc = "Gb";
                    if (pc === "G#") pc = "Ab";
                    if (pc === "A#") pc = "Bb";
                    return pc;
                }
                return null;
            }


            // --- Drawing Functions ---
            function drawStaffLine(y) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvasWidth, y);
                ctx.lineWidth = STAFF_LINE_WIDTH;
                ctx.strokeStyle = STAFF_LINE_COLOR;
                ctx.stroke();
            }

            function drawGrandStaff() {
                // Treble Staff Lines (E4, G4, B4, D5, F5)
                drawStaffLine(staffPositions.E4); drawStaffLine(staffPositions.G4); drawStaffLine(staffPositions.B4); drawStaffLine(staffPositions.D5); drawStaffLine(staffPositions.F5);
                // Bass Staff Lines (G2, B2, D3, F3, A3)
                drawStaffLine(staffPositions.G2); drawStaffLine(staffPositions.B2); drawStaffLine(staffPositions.D3); drawStaffLine(staffPositions.F3); drawStaffLine(staffPositions.A3);
            }

            function drawRoundedRect(x, y, width, height, radius) {
                if (width < 2 * radius) radius = width / 2;
                if (height < 2 * radius) radius = height / 2;
                if (width <= 0 || height <= 0) return; // Don't draw zero/negative size rects
                ctx.beginPath();
                ctx.moveTo(x + radius, y);
                ctx.arcTo(x + width, y, x + width, y + height, radius);
                ctx.arcTo(x + width, y + height, x, y + height, radius);
                ctx.arcTo(x, y + height, x, y, radius);
                ctx.arcTo(x, y, x + width, y, radius);
                ctx.closePath();
                ctx.fill();
            }

            function drawLedgerLines(note, x, noteWidth) {
                const y = note.y; if (y === null) return;
                const checkTolerance = HALF_LINE_SPACING / 2; // Tolerance for checking proximity to lines
                ctx.lineWidth = LEDGER_LINE_WIDTH;
                ctx.strokeStyle = STAFF_LINE_COLOR;
                const ledgerXStart = x - LEDGER_LINE_EXTENSION;
                const ledgerXEnd = x + noteWidth + LEDGER_LINE_EXTENSION;

                // Ledger lines ABOVE treble staff (F5 is top line)
                if (y < staffPositions.F5 - checkTolerance) {
                    for (let lineY = staffPositions.F5 - LINE_SPACING; lineY >= y - checkTolerance; lineY -= LINE_SPACING) {
                        ctx.beginPath(); ctx.moveTo(ledgerXStart, lineY); ctx.lineTo(ledgerXEnd, lineY); ctx.stroke();
                    }
                }
                // Ledger line FOR Middle C (C4) - check if note is ON C4 line
                if (Math.abs(y - staffPositions.C4) < checkTolerance) {
                    ctx.beginPath(); ctx.moveTo(ledgerXStart, staffPositions.C4); ctx.lineTo(ledgerXEnd, staffPositions.C4); ctx.stroke();
                }
                 // Ledger lines BELOW bass staff (G2 is bottom line)
                if (y > staffPositions.G2 + checkTolerance) {
                    for (let lineY = staffPositions.G2 + LINE_SPACING; lineY <= y + checkTolerance; lineY += LINE_SPACING) {
                        ctx.beginPath(); ctx.moveTo(ledgerXStart, lineY); ctx.lineTo(ledgerXEnd, lineY); ctx.stroke();
                    }
                }
            }

            /** Draws the accidental symbol (# or b) on top of the note start */
            function drawAccidental(note, x) { // x is the starting x of the note rectangle
                const accidental = note.name.includes('#') ? '♯' : note.name.includes('b') ? '♭' : null;
                if (accidental && note.y !== null) {
                    // Set color based on useColoredNotes global variable
                    ctx.fillStyle = useColoredNotes ? ACCIDENTAL_COLOR_COLOR_NOTES : ACCIDENTAL_COLOR_BLACK_NOTES;
                    ctx.font = `${ACCIDENTAL_FONT_SIZE}px sans-serif`;
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'middle';
                    const accidentalX = x + ACCIDENTAL_PADDING_X;
                    const accidentalY = note.y; // Center vertically on the note's Y
                    ctx.fillText(accidental, accidentalX, accidentalY);
                }
            }


            function drawNote(note, currentTime) {
                // Don't draw if already hit successfully
                if (note.hitStatus === 'good' || note.hitStatus === 'perfect') {
                    return;
                }
                // Continue drawing if missed or not yet judged
                if (note.y === null || note.y === undefined) { return; } // Skip notes with invalid Y positions

                const noteY = note.y; // Center Y position
                const timeUntilJudgment = note.time - currentTime; // Use current time from animation loop
                // Use the global SCROLL_SPEED_PIXELS_PER_SECOND
                const noteX = judgmentLineX + (timeUntilJudgment * SCROLL_SPEED_PIXELS_PER_SECOND);
                const noteWidth = Math.max(1, note.duration * SCROLL_SPEED_PIXELS_PER_SECOND); // Ensure minimum width of 1px
                const noteHeight = LINE_SPACING; // Note height matches line spacing

                // Determine note color (using global useColoredNotes)
                let currentNoteColor = NOTE_COLOR; // Default black/grey
                if (useColoredNotes) { // Check global variable
                    if (typeof getMidiNoteColor === 'function') {
                        try {
                            const rgbArray = getMidiNoteColor(note.midi);
                            if (rgbArray && rgbArray.length === 3) {
                                currentNoteColor = `rgb(${rgbArray[0]}, ${rgbArray[1]}, ${rgbArray[2]})`;
                            } else { currentNoteColor = NOTE_COLOR; } // Fallback
                        } catch (e) { console.error(`Staff: Error calling getMidiNoteColor:`, e); currentNoteColor = NOTE_COLOR; }
                    } else { currentNoteColor = NOTE_COLOR; } // Fallback if function missing
                }

                // Draw only if potentially visible (basic culling)
                // Note: Missed notes will continue to be drawn until they scroll off
                if (noteX < canvasWidth && (noteX + noteWidth) > 0) {
                    drawLedgerLines(note, noteX, noteWidth); // Draw ledger lines first (behind)
                    ctx.fillStyle = currentNoteColor; // Set the determined color
                    drawRoundedRect(noteX, noteY - noteHeight / 2, noteWidth, noteHeight, NOTE_CORNER_RADIUS); // Draw note body
                    // Draw accidental AFTER note body so it's on top
                    drawAccidental(note, noteX);
                }
            }

            function drawJudgmentLine() {
                 ctx.beginPath();
                 ctx.moveTo(judgmentLineX, 0);
                 ctx.lineTo(judgmentLineX, canvasHeight);
                 ctx.lineWidth = JUDGMENT_LINE_WIDTH;
                 ctx.strokeStyle = JUDGMENT_LINE_COLOR;
                 ctx.stroke();
            }

            /** Draws active perfect hit flash effects */
            function drawFlashes(currentTime) {
                if (activeFlashes.length === 0) return;

                ctx.fillStyle = PERFECT_FLASH_COLOR;
                const flashHeight = LINE_SPACING * 1.5; // Make flash slightly taller than note
                const flashWidth = 10; // Fixed width for the flash effect

                // Iterate backwards for safe removal
                for (let i = activeFlashes.length - 1; i >= 0; i--) {
                    const flash = activeFlashes[i];
                    if (currentTime >= flash.endTime) {
                        activeFlashes.splice(i, 1); // Remove expired flash
                    } else {
                        // Draw the flash centered vertically on the note's Y
                        drawRoundedRect(
                            judgmentLineX - flashWidth / 2,
                            flash.y - flashHeight / 2,
                            flashWidth,
                            flashHeight,
                            flashWidth / 2 // Make it oval/circular
                        );
                    }
                }
            }


            function redrawCanvas(currentTime) { // Renamed parameter for clarity
                if (!ctx) return; // Don't draw if context is not available
                ctx.save(); // Save default context state
                // Clear the canvas (physical pixels)
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                // Scale the context coordinate system for high-DPI displays
                ctx.scale(devicePixelRatio, devicePixelRatio);

                // --- Drawing ---
                // Draw static elements
                drawGrandStaff();
                drawJudgmentLine();

                // Draw dynamic elements (notes)
                if (notesToDraw.length > 0) {
                    // Pass the current displayTime to drawNote
                    notesToDraw.forEach(note => drawNote(note, currentTime));
                } else {
                    // Optionally draw a "Loading..." or "No notes" message
                    ctx.fillStyle = '#888';
                    ctx.font = '16px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle'; // Center text vertically
                    ctx.fillText('Loading notes...', canvasWidth / 2, canvasHeight / 2);
                }

                // Draw perfect hit flashes on top
                drawFlashes(currentTime);
                // ---------------

                ctx.restore(); // Restore context state
            }

            // --- Animation Loop ---
            function animationLoop(timestamp) {
                if (!isStaffRunning || isGameOver) { // Stop loop if paused or game over
                     animationFrameId = null;
                     return;
                }

                const currentTimeSeconds = timestamp / 1000.0;
                // Calculate time elapsed since last frame, prevent large jumps on pause/resume
                const deltaTime = lastTimestamp > 0 ? Math.min(0.1, currentTimeSeconds - lastTimestamp) : 0; // Cap delta time
                displayTime += deltaTime; // Advance the display time

                lastTimestamp = currentTimeSeconds; // Store timestamp for next frame calculation

                // --- Check for Missed Notes ---
                // Use the global HIT_WINDOW_GOOD_SEC
                const missThresholdTime = displayTime - HIT_WINDOW_GOOD_SEC;
                notesToDraw.forEach(note => {
                    // Check only notes that haven't been judged yet
                    if (!note.hitStatus && note.time < missThresholdTime) {
                        note.hitStatus = 'miss';
                        // console.log(`Note Missed: ${note.name} (Time: ${note.time.toFixed(3)}, Display: ${displayTime.toFixed(3)})`); // Reduce noise
                        // Apply scoring for miss
                        applyScore('miss'); // Call the global scoring function
                    }
                });

                // --- Check for Song End ---
                if (songEndTime > 0 && displayTime >= songEndTime) {
                    triggerGameOver(true); // Pass true indicating song finished
                    // Loop will terminate because isGameOver is now true
                }

                redrawCanvas(displayTime); // Redraw everything for the new time

                animationFrameId = requestAnimationFrame(animationLoop); // Request next frame
            }

            // --- Judgment Logic ---
            /**
             * Judges a key press against notes near the judgment line.
             * @param {string} keyName - The name of the key pressed (e.g., "C", "Db").
             * @returns {string | null} - 'perfect', 'good', or null if no note was hit.
             */
            function judgeKeyPress(keyName) {
                if (!isStaffRunning || isGameOver) return null; // Don't judge if paused or game over

                const currentTime = displayTime; // Use the current visual time
                let hitResult = null; // Track if we hit anything

                // Find the *earliest* unhandled note of the correct pitch class within the "Good" window
                let bestNote = null;
                let minTimeDiff = Infinity;

                for (const note of notesToDraw) {
                    // Skip notes already handled or too far away in the past/future
                    if (note.hitStatus) continue;

                    const timeDiff = note.time - currentTime; // Positive if note is in future, negative if in past
                    const absTimeDiff = Math.abs(timeDiff);

                    // Check if within the wider "Good" window (use global variable)
                    if (absTimeDiff <= HIT_WINDOW_GOOD_SEC) {
                        // Check if the pitch class matches
                        const notePitchClass = getPitchClass(note.name);
                        if (notePitchClass === keyName) {
                            // If this note is earlier *or closer to the judgment line* than the current best, select it
                            // Prioritize notes closer to the judgment line (smaller absTimeDiff)
                            if (absTimeDiff < minTimeDiff) {
                                minTimeDiff = absTimeDiff;
                                bestNote = note;
                            }
                        }
                    }
                }

                // If we found a matching note in the window
                if (bestNote) {
                    // Determine Perfect or Good based on the absolute time difference (use global variable)
                    if (minTimeDiff <= HIT_WINDOW_PERFECT_SEC) {
                        bestNote.hitStatus = 'perfect';
                        hitResult = 'perfect';
                        // console.log(`PERFECT Hit: ${bestNote.name} (Diff: ${minTimeDiff.toFixed(3)}s)`); // Reduce noise
                        // Trigger flash effect
                        activeFlashes.push({ y: bestNote.y, endTime: currentTime + PERFECT_FLASH_DURATION_MS / 1000.0 });
                        // Apply scoring for perfect
                        applyScore('perfect'); // Call the global scoring function
                    } else {
                        bestNote.hitStatus = 'good';
                        hitResult = 'good';
                        // console.log(`GOOD Hit: ${bestNote.name} (Diff: ${minTimeDiff.toFixed(3)}s)`); // Reduce noise
                         // Apply scoring for good
                        applyScore('good'); // Call the global scoring function
                    }
                } else {
                    // No matching note found in the window for this key press
                    // console.log(`Key press ${keyName} - No matching note in window.`); // Reduce noise
                    // TODO: Optionally apply a penalty for pressing a key when no note is there?
                }

                return hitResult; // Return 'perfect', 'good', or null
            }


            // --- Control Functions (Internal) ---
            function playAnimationInternal() {
                if (!isStaffRunning && !isGameOver) { // Don't play if game over
                    console.log("Staff: Playing animation (Internal)...");
                    isStaffRunning = true;
                    canvas.style.cursor = 'default'; // Normal cursor when playing
                    // Reset timestamp to avoid large jump after pause
                    lastTimestamp = performance.now() / 1000.0;
                    if (!animationFrameId) { // Avoid multiple loops if already requested
                        animationFrameId = requestAnimationFrame(animationLoop);
                    }
                }
            }

            function pauseAnimationInternal() {
                if (isStaffRunning) {
                    console.log("Staff: Pausing animation (Internal)...");
                    isStaffRunning = false; // Flag checked by animationLoop to stop
                    canvas.style.cursor = 'grab'; // Grab cursor when paused/draggable
                    // Clear lastTimestamp to calculate fresh delta on resume
                    lastTimestamp = 0;
                }
            }

            /** Resets the hit status of all notes */
            function resetNotesInternal() {
                console.log("Staff: Resetting note hit statuses.");
                notesToDraw.forEach(note => note.hitStatus = null);
                activeFlashes = []; // Clear any active flashes
            }

            /** Resets the display time to the beginning */
            function resetTimeInternal() {
                 console.log("Staff: Resetting display time.");
                 displayTime = PRE_DELAY_SECONDS;
                 lastTimestamp = 0; // Reset last timestamp for delta calculation
            }

            // --- Event Handlers ---
            function handleResize() {
                // console.log("Staff: Handling resize..."); // Reduce noise
                // Get the available dimensions of the container element
                const displayWidth = staffSection.offsetWidth;
                const displayHeight = staffSection.offsetHeight;

                // Ensure dimensions are valid before proceeding
                if (displayWidth <= 0 || displayHeight <= 0) {
                    console.warn("Staff: Resize called with zero or negative dimensions. Skipping redraw.");
                    return;
                }

                // Set logical canvas width to fill container
                canvasWidth = displayWidth;
                // Use the pre-calculated logical height, but cap it at the container's actual height
                canvasHeight = Math.min(displayHeight, totalStaffLogicalHeight);

                // Adjust canvas buffer size for pixel density
                canvas.width = Math.round(canvasWidth * devicePixelRatio);
                canvas.height = Math.round(canvasHeight * devicePixelRatio);

                // Set canvas display size using CSS
                canvas.style.width = `${canvasWidth}px`;
                canvas.style.height = `${canvasHeight}px`;

                // Recalculate judgment line logical X position based on new canvasWidth
                judgmentLineX = canvasWidth * (JUDGMENT_LINE_X_PERCENT / 100);

                // console.log(`Staff: Canvas resized - Container: ${displayWidth}x${displayHeight}, Logical: ${canvasWidth.toFixed(0)}x${canvasHeight.toFixed(1)}px, Buffer: ${canvas.width}x${canvas.height}px`); // Reduce noise
                redrawCanvas(displayTime); // Redraw immediately with new dimensions
            }

            function getEventX(event) { return event.touches ? event.touches[0].clientX : event.clientX; }

            function handleDragStart(event) {
                // Only allow dragging if the game is NOT running and NOT over
                if (!isStaffRunning && !isGameOver) {
                    isDragging = true;
                    // Calculate starting X relative to the canvas element's bounding box
                    dragStartX = getEventX(event) - canvas.getBoundingClientRect().left;
                    dragStartTime = displayTime; // Store time at drag start
                    canvas.classList.add('dragging'); // Add class for styling
                    // Prevent default only if the event target is the canvas itself
                    if (event.target === canvas) {
                         event.preventDefault(); // Prevent text selection, etc.
                    }
                }
            }

            function handleDragMove(event) {
                if (isDragging) { // Dragging state implies game is paused and not over
                    const currentX = getEventX(event) - canvas.getBoundingClientRect().left;
                    const deltaX = currentX - dragStartX; // Pixel difference from start

                    // Convert pixel delta to time delta (negative because dragging right moves time backward)
                    // Use the global SCROLL_SPEED_PIXELS_PER_SECOND
                    const deltaTimeOffset = deltaX / SCROLL_SPEED_PIXELS_PER_SECOND;

                    // Calculate new display time, clamping at the minimum allowed time
                    displayTime = Math.max(MIN_DISPLAY_TIME, dragStartTime - deltaTimeOffset);

                    redrawCanvas(displayTime); // Redraw canvas at the new time
                    // Prevent default only if the event target is the canvas itself
                    if (event.target === canvas) {
                         event.preventDefault();
                    }
                }
            }

            function handleDragEnd(event) {
                if (isDragging) {
                    isDragging = false;
                    canvas.classList.remove('dragging');
                    // Prevent default only if the event target is the canvas itself
                    if (event.target === canvas) {
                        event.preventDefault();
                    }
                }
            }

            // --- Initialization ---
            async function loadNoteData() {
                 console.log(`Staff: Loading note data from: ${NOTE_DATA_URL}`);
                 try {
                      const response = await fetch(NOTE_DATA_URL);
                      if (!response.ok) {
                          throw new Error(`HTTP error! status: ${response.status}`);
                      }
                      const jsonData = await response.json(); // Parse JSON response

                      noteMap = jsonData; // Assign the fetched data
                      console.log("Staff: Note data loaded successfully via fetch.");

                      // Process notes from the first track ONLY, as per specs
                      if (noteMap && noteMap.tracks && noteMap.tracks.length > 0 && noteMap.tracks[0].notes) {
                         const rawNotes = noteMap.tracks[0].notes;
                         console.log(`Staff: Found ${rawNotes.length} notes in the first track.`);

                         totalNotesInSong = rawNotes.length; // Store total notes for percentage calculation
                         let lastNoteEndTime = 0;

                         notesToDraw = rawNotes
                             .map(note => {
                                 const yPos = getNoteYPosition(note.name);
                                 const noteEndTime = note.time + note.duration;
                                 if (noteEndTime > lastNoteEndTime) {
                                     lastNoteEndTime = noteEndTime;
                                 }
                                 return {
                                     ...note,
                                     y: yPos,
                                     hitStatus: null // Initialize hit status
                                 };
                             })
                             .filter(note => note.y !== null); // Filter out notes where Y lookup failed

                         songEndTime = lastNoteEndTime + SONG_END_BUFFER_SEC; // Set song end time
                         console.log(`Staff: Processed ${rawNotes.length} notes, ${notesToDraw.length} remain after Y position lookup and filtering. Calculated song end time: ${songEndTime.toFixed(3)}s`);

                         // Sort notes by start time for efficient processing/drawing
                         notesToDraw.sort((a, b) => a.time - b.time);
                         // console.log("Staff: Notes sorted by start time."); // Reduce noise

                      } else {
                          console.error("Staff Error: Fetched note data is missing tracks[0] or tracks[0].notes, or has an invalid format.");
                          notesToDraw = [];
                          totalNotesInSong = 0;
                          songEndTime = 0;
                      }
                 } catch (error) {
                     console.error("Staff: Fatal Error loading or processing note data:", error);
                     notesToDraw = []; // Ensure notesToDraw is empty on error
                     totalNotesInSong = 0;
                     songEndTime = 0;
                 }
             }

            // Public init function for the module
            async function init() {
                console.log("Staff Module: Initializing...");
                // Verify getMidiNoteColor function exists
                if (typeof getMidiNoteColor !== 'function') {
                    console.error("Staff CRITICAL: getMidiNoteColor function NOT FOUND.");
                }

                await loadNoteData(); // Load data from URL
                handleResize(); // Set initial size
                displayTime = PRE_DELAY_SECONDS; // Set initial view time
                redrawCanvas(displayTime); // Draw initial frame

                // Add event listeners (Dragging only)
                canvas.addEventListener('mousedown', handleDragStart);
                window.addEventListener('mousemove', handleDragMove);
                window.addEventListener('mouseup', handleDragEnd);
                canvas.addEventListener('touchstart', handleDragStart, { passive: false });
                window.addEventListener('touchmove', handleDragMove, { passive: false });
                window.addEventListener('touchend', handleDragEnd);
                window.addEventListener('touchcancel', handleDragEnd);

                console.log("Staff Module: Initialization complete.");
            }

            // --- Public Interface ---
            return {
                init,
                handleResize,
                play: playAnimationInternal,
                pause: pauseAnimationInternal,
                redraw: () => redrawCanvas(displayTime), // Expose redraw for color changes
                isRunning: () => isStaffRunning, // Expose running state
                judgeKeyPress: judgeKeyPress, // Expose judgment function
                resetNotes: resetNotesInternal, // Expose note reset function
                resetTime: resetTimeInternal   // Expose time reset function
            };

        })(); // Immediately invoke the staff module function

        // --- Keyboard Component Logic ---
        const keyboardModule = (() => {
            console.log("Initializing Keyboard Module...");

            // --- DOM Elements (Keyboard Specific) ---
            const pianoContainer = document.getElementById('piano');
            if (!pianoContainer) {
                console.error("Keyboard Error: Piano container element not found!");
                return null; // Stop module initialization
            }
            const keys = pianoContainer.querySelectorAll('.key'); // Get all key elements within the piano

            // --- State Variables ---
            let isMouseDown = false; // Track mouse button state specifically for keyboard
            let activeTouches = {}; // Store currently active key per touch identifier: { touchId: keyElement }
            let judgeFunction = null; // To hold the reference to staffModule.judgeKeyPress

            // --- Helper Functions ---
            function pressKey(keyElement) {
                if (isGameOver) return; // Don't allow key presses after game over
                if (keyElement && !keyElement.classList.contains('pressed')) {
                    keyElement.classList.add('pressed');
                    const keyName = keyElement.dataset.key;
                    // console.log(`Keyboard: Pressed: ${keyName}`); // Reduce noise

                    // Call the judgment function if it exists and game is running
                    if (judgeFunction && gameIsRunning) { // Only judge if game is running
                        judgeFunction(keyName);
                    } else if (!gameIsRunning) {
                         // console.log("Keyboard: Key pressed but game is paused."); // Reduce noise
                    } else {
                        console.warn("Keyboard: Judge function not available!");
                    }
                }
            }

            function releaseKey(keyElement) {
                if (keyElement && keyElement.classList.contains('pressed')) {
                    keyElement.classList.remove('pressed');
                    // console.log(`Keyboard: Released: ${keyElement.dataset.key}`);
                }
            }

            // --- Event Handlers ---
            function handleMouseDown(event) {
                // Ensure it's the primary mouse button (usually left)
                if (event.button !== 0) return;

                const targetKey = event.target.closest('.key');
                // Check if the click was on a valid key within this piano container
                if (targetKey && pianoContainer.contains(targetKey)) {
                    isMouseDown = true; // Set the flag indicating the mouse button is down *for the keyboard*
                    pressKey(targetKey); // Press the key visually and trigger judgment
                    event.preventDefault(); // Prevent potential text selection or dragging page
                }
            }

            function handleMouseUp(event) {
                // Ensure it's the primary mouse button
                if (event.button !== 0) return;

                // If the mouse button was down *for the keyboard*
                if (isMouseDown) {
                    // Release all keys visually within this piano
                    keys.forEach(releaseKey);
                    isMouseDown = false; // Reset the keyboard's mouse button state
                }
            }

             // Mouse Leave Handler (listens on the specific piano container)
            function handleMouseLeave(event) {
                // If the mouse leaves the piano container *while* the button is pressed *for the keyboard*
                if (isMouseDown && event.target === pianoContainer) {
                    // Release all keys visually for this piano
                    keys.forEach(releaseKey);
                    isMouseDown = false; // Reset the keyboard's mouse button state
                }
            }

            // --- Touch Handlers ---
            function handleTouchStart(event) {
                // Prevent default actions ONLY if the touch starts directly on a key
                const initialTargetKey = event.target.closest('.key');
                 if (initialTargetKey && pianoContainer.contains(initialTargetKey)) {
                     event.preventDefault(); // Prevent scroll/zoom ONLY when starting on a key
                 }

                for (let i = 0; i < event.changedTouches.length; i++) {
                    const touch = event.changedTouches[i];
                    // Find the element directly under the touch point
                    const elementUnderTouch = document.elementFromPoint(touch.clientX, touch.clientY);
                    const targetKey = elementUnderTouch ? elementUnderTouch.closest('.key') : null;

                    // Ensure the touch started on a valid key within this piano
                    if (targetKey && pianoContainer.contains(targetKey)) {
                        const touchId = touch.identifier; // Get unique ID for this touch
                        if (!activeTouches[touchId]) {
                            activeTouches[touchId] = targetKey; // Store the key associated with this touch ID
                            pressKey(targetKey); // Press the key visually and trigger judgment
                        }
                    }
                }
            }

            function handleTouchMove(event) {
                 // Prevent default actions ONLY if one of the moved touches is currently active on a key
                 let shouldPreventDefault = false;
                 for (let i = 0; i < event.changedTouches.length; i++) {
                     const touch = event.changedTouches[i];
                     if (activeTouches[touch.identifier]) {
                         shouldPreventDefault = true;
                         break;
                     }
                 }
                 if (shouldPreventDefault) {
                     event.preventDefault(); // Prevent scrolling while dragging over keys
                 }


                for (let i = 0; i < event.changedTouches.length; i++) {
                    const touch = event.changedTouches[i];
                    const touchId = touch.identifier;

                    // Find the element *currently* under the touch point
                    const elementUnderTouch = document.elementFromPoint(touch.clientX, touch.clientY);
                    const currentKey = elementUnderTouch ? elementUnderTouch.closest('.key') : null;

                    // Check if the current element is a valid key within this piano
                    const isValidKey = currentKey && pianoContainer.contains(currentKey);
                    // Get the key that was previously active for this specific touch
                    const previousKey = activeTouches[touchId];

                    // Only process if this touch started on a key (is being tracked)
                    if (previousKey !== undefined) {
                        // If the key under the touch has changed OR if the touch moved off a key entirely
                        if (currentKey !== previousKey) {
                            // Release the previous key visually (if it exists)
                            releaseKey(previousKey);

                            // If the touch is now over a new valid key, press it and update tracking
                            if (isValidKey) {
                                activeTouches[touchId] = currentKey; // Update the active key for this touch
                                pressKey(currentKey); // Press the NEW key visually and trigger judgment
                            } else {
                                // Touch moved off the piano or onto a non-key element
                                activeTouches[touchId] = null; // Mark this touch as not on a key anymore (but keep tracking ID until touchend)
                            }
                        }
                    }
                }
            }

            function handleTouchEndOrCancel(event) {
                // Prevent default only if the ending touch was active on a key
                let shouldPreventDefault = false;
                for (let i = 0; i < event.changedTouches.length; i++) {
                    const touch = event.changedTouches[i];
                    if (activeTouches[touch.identifier]) {
                        shouldPreventDefault = true;
                        break;
                    }
                }
                if (shouldPreventDefault) {
                    event.preventDefault();
                }

                for (let i = 0; i < event.changedTouches.length; i++) {
                    const touch = event.changedTouches[i];
                    const touchId = touch.identifier;
                    // Get the last key this touch was associated with
                    const lastKey = activeTouches[touchId];

                    // Release the last key visually, if there was one
                    releaseKey(lastKey);

                    // Remove this touch from the tracking object
                    delete activeTouches[touchId];
                }
            }

            // Public init function for the module
            function init(judgeKeyPressFunc) { // Accept the judge function as an argument
                console.log("Keyboard Module: Initializing...");
                judgeFunction = judgeKeyPressFunc; // Store the function reference

                // --- Attach Event Listeners ---
                pianoContainer.addEventListener('mousedown', handleMouseDown);
                document.addEventListener('mouseup', handleMouseUp);
                pianoContainer.addEventListener('mouseleave', handleMouseLeave);
                pianoContainer.addEventListener('touchstart', handleTouchStart, { passive: false });
                pianoContainer.addEventListener('touchmove', handleTouchMove, { passive: false });
                pianoContainer.addEventListener('touchend', handleTouchEndOrCancel, { passive: false });
                pianoContainer.addEventListener('touchcancel', handleTouchEndOrCancel, { passive: false });
                pianoContainer.addEventListener('contextmenu', (event) => event.preventDefault());

                console.log("Keyboard Module: Initialization complete.");
            }

            // Expose necessary functions/variables if needed
            return {
                init
            };

        })(); // Immediately invoke the keyboard module function

        // --- Global UI Update Functions ---
        /** Updates the health bar and combo display */
        function updateInfoUI() {
            // Update Combo Count
            if (comboCountSpan) {
                comboCountSpan.textContent = comboCount;
            }

            // Update Health Bar
            if (healthBarElement) {
                const healthPercentage = Math.max(0, Math.min(100, (playerHealth / MAX_HEALTH) * 100));
                healthBarElement.style.width = `${healthPercentage}%`;
                // Optional: Change color based on health
                if (healthPercentage <= 0) {
                     healthBarElement.style.backgroundColor = '#555555'; // Dark grey when empty
                } else if (healthPercentage < 25) {
                    healthBarElement.style.backgroundColor = '#f44336'; // Red
                } else if (healthPercentage < 50) {
                    healthBarElement.style.backgroundColor = '#ff9800'; // Orange
                } else {
                    healthBarElement.style.backgroundColor = '#4CAF50'; // Green
                }
            }
            // console.log(`UI Updated: Health=${playerHealth}/${MAX_HEALTH}, Combo=${comboCount}`); // Reduce console noise
        }

        /** Updates the displayed values in the settings panel */
        function updateSettingsUI() {
            if (staffScaleValueSpan) {
                staffScaleValueSpan.textContent = SCROLL_SPEED_PIXELS_PER_SECOND;
            }
            if (hitWindowValueSpan) {
                 hitWindowValueSpan.textContent = HIT_WINDOW_GOOD_MS;
            }
             if (colorToggleSwitch) {
                colorToggleSwitch.checked = useColoredNotes;
            }
            if (noDeathToggleSwitch) {
                noDeathToggleSwitch.checked = noDeathMode;
            }
            console.log("Settings UI updated.");
        }

        // --- Global Initialization & Layout Management ---

        /** Handles layout adjustments needed on orientation change or resize */
        function handleLayoutChange() {
            const orientation = window.matchMedia("(orientation: landscape)").matches ? 'landscape' : 'portrait';
            // console.log(`Layout Check. Orientation: ${orientation}`); // Reduce noise

            // Move infoSection into bottomPanel for landscape, or back to gameContainer for portrait
            if (orientation === 'landscape') {
                if (infoSection.parentElement !== bottomPanel) {
                    bottomPanel.insertBefore(infoSection, keyboardSection); // Place info before keyboard
                    // console.log("Moved infoSection into bottomPanel for landscape."); // Reduce noise
                }
            } else { // Portrait
                if (infoSection.parentElement === bottomPanel) {
                    gameContainer.insertBefore(infoSection, staffSection); // Place info before staff
                    // console.log("Moved infoSection back to gameContainer for portrait."); // Reduce noise
                }
            }

            // Trigger resize for staff canvas after potential layout shifts
            if (staffModule && typeof staffModule.handleResize === 'function') {
                 setTimeout(staffModule.handleResize, 50); // Short delay
                 // console.log("Scheduled staff resize."); // Reduce noise
            } else {
                console.warn("Could not trigger staff resize after layout change.");
            }
        }

        /** Recalculates derived timing variables when HIT_WINDOW_GOOD_MS changes */
        function updateTimingWindows() {
            HIT_WINDOW_PERFECT_MS = Math.floor(HIT_WINDOW_GOOD_MS / 2); // Ensure perfect is half
            HIT_WINDOW_GOOD_SEC = HIT_WINDOW_GOOD_MS / 1000.0;
            HIT_WINDOW_PERFECT_SEC = HIT_WINDOW_PERFECT_MS / 1000.0;
            console.log(`Timing windows updated: Good=${HIT_WINDOW_GOOD_MS}ms, Perfect=${HIT_WINDOW_PERFECT_MS}ms`);
        }


        /** Main initialization function */
        async function initializeGame() {
            console.log("--- Initializing Keytap Game ---");

            // Initialize Modules
            // Staff module needs to be initialized first as keyboard needs its judge function
            if (staffModule) await staffModule.init(); else console.error("Staff module failed to load.");

            // Pass the judgeKeyPress function from staff to keyboard during initialization
            if (keyboardModule && staffModule && typeof staffModule.judgeKeyPress === 'function') {
                 keyboardModule.init(staffModule.judgeKeyPress);
            } else {
                console.error("Keyboard module or staff judge function failed to load/initialize.");
            }


            // Set initial UI states
            updateInfoUI(); // Set initial health bar and combo
            updateSettingsUI(); // Set initial settings display

            // Set initial layout based on current orientation/size
            handleLayoutChange();

            // --- Add Global Event Listeners ---

            // Play/Pause Button
            if (playPauseButton && staffModule) {
                playPauseButton.addEventListener('click', () => {
                    if (isGameOver) return; // Don't allow play/pause after game over

                    if (gameIsRunning) {
                        staffModule.pause();
                        playPauseButton.textContent = "Play";
                        gameIsRunning = false;
                    } else {
                        staffModule.play();
                        playPauseButton.textContent = "Pause";
                        gameIsRunning = true;
                    }
                    console.log(`Play/Pause toggled. Game running: ${gameIsRunning}`);
                });
            }

            // Settings Button
            if (settingsButton && settingsOverlay && staffModule) {
                settingsButton.addEventListener('click', () => {
                    if (isGameOver) return; // Don't allow settings after game over
                    console.log("Settings button clicked.");
                    // Pause the game first if it's running
                    if (gameIsRunning) {
                        staffModule.pause();
                        playPauseButton.textContent = "Play"; // Update main button text
                        gameIsRunning = false;
                        console.log("Paused game for settings.");
                    }
                    // Ensure settings UI reflects current values before showing
                    updateSettingsUI();
                    // Show overlay
                    settingsOverlay.classList.add('visible');
                });
            }

            // Close Settings Button
            if (closeSettingsButton && settingsOverlay) {
                closeSettingsButton.addEventListener('click', () => {
                    settingsOverlay.classList.remove('visible');
                    console.log("Settings overlay closed.");
                    // Leave paused. User must press Play again.
                });
            }

             // Settings: Color Toggle Switch
             if (colorToggleSwitch && staffModule) {
                 colorToggleSwitch.addEventListener('change', (event) => {
                     useColoredNotes = event.target.checked;
                     console.log(`Color notes setting changed: ${useColoredNotes}`);
                     // Immediately redraw the staff with the new setting
                     staffModule.redraw();
                 });
             }

             // Settings: No Death Mode Toggle Switch
             if (noDeathToggleSwitch) {
                 noDeathToggleSwitch.addEventListener('change', (event) => {
                     noDeathMode = event.target.checked;
                     console.log(`No Death Mode setting changed: ${noDeathMode}`);
                 });
             }

             // Settings: Staff Scale Adjustment
             const STAFF_SCALE_STEP = 10;
             const STAFF_SCALE_MIN = 50;
             const STAFF_SCALE_MAX = 200;
             if (staffScaleDownButton) {
                 staffScaleDownButton.addEventListener('click', () => {
                     SCROLL_SPEED_PIXELS_PER_SECOND = Math.max(STAFF_SCALE_MIN, SCROLL_SPEED_PIXELS_PER_SECOND - STAFF_SCALE_STEP);
                     updateSettingsUI();
                     staffModule.redraw(); // Redraw needed to see effect if paused
                 });
             }
             if (staffScaleUpButton) {
                 staffScaleUpButton.addEventListener('click', () => {
                     SCROLL_SPEED_PIXELS_PER_SECOND = Math.min(STAFF_SCALE_MAX, SCROLL_SPEED_PIXELS_PER_SECOND + STAFF_SCALE_STEP);
                     updateSettingsUI();
                     staffModule.redraw(); // Redraw needed to see effect if paused
                 });
             }

             // Settings: Hit Window Adjustment
             const HIT_WINDOW_STEP = 5;
             const HIT_WINDOW_MIN = 30; // Min Good window (Perfect will be 15)
             const HIT_WINDOW_MAX = 150; // Max Good window (Perfect will be 75)
             if (hitWindowDownButton) {
                 hitWindowDownButton.addEventListener('click', () => {
                     HIT_WINDOW_GOOD_MS = Math.max(HIT_WINDOW_MIN, HIT_WINDOW_GOOD_MS - HIT_WINDOW_STEP);
                     updateTimingWindows(); // Recalculate dependent variables
                     updateSettingsUI();
                 });
             }
              if (hitWindowUpButton) {
                 hitWindowUpButton.addEventListener('click', () => {
                     HIT_WINDOW_GOOD_MS = Math.min(HIT_WINDOW_MAX, HIT_WINDOW_GOOD_MS + HIT_WINDOW_STEP);
                     updateTimingWindows(); // Recalculate dependent variables
                     updateSettingsUI();
                 });
             }


             // Score Screen: Restart Button
             if (restartButton) {
                 restartButton.addEventListener('click', restartGame);
             }

            // Orientation Change Listener
            window.matchMedia("(orientation: landscape)").addEventListener("change", handleLayoutChange);

            // Window Resize Listener (Debounced)
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    // console.log("Window resize detected, running layout check."); // Reduce noise
                    handleLayoutChange();
                }, 150); // Wait 150ms after last resize event
            });

            console.log("--- Keytap Game Initialization Complete ---");
        }

        // --- Entry Point ---
        window.addEventListener('load', initializeGame);
        console.log("Global: window.onload event listener added for initializeGame.");

    </script>

</body>
</html>
